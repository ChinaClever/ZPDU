// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: peersafe/imapi/im.proto

#ifndef PROTOBUF_peersafe_2fimapi_2fim_2eproto__INCLUDED
#define PROTOBUF_peersafe_2fimapi_2fim_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace peersafe {
namespace imapi {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

class ClientMessage;
class OidMessage;
class MultiOidMessage;
class SyncMessage;
class UserMessage;
class UserMessageReply;
class IceKeepalive;
class FriendRequest;
class FriendReply;
class IceService;
class IceServiceCache;
class IceHandleShake;
class IceSdp;
class ChannelMessage;
class DirectConnectionMessage;
class GroupChatInvite;
class GroupChatInviteReply;
class GroupUserMessage;
class GroupChannelData;
class GroupChannelDatas;
class GroupSyncChatInvite;
class GroupSyncChatInviteReply;
class GroupSyncNewMember;
class GroupSyncRemoveMember;
class GroupSyncUserMessage;
class GroupSyncChangeName;

enum ClientMessage_MessageType {
  ClientMessage_MessageType_USER_MESSAGE = 0,
  ClientMessage_MessageType_USER_MESSAGE_ACK = 1,
  ClientMessage_MessageType_FRIEND_REQUEST = 2,
  ClientMessage_MessageType_FRIEND_REQUEST_REPLY = 3,
  ClientMessage_MessageType_NOTIFY_FRIEND_DELETE = 4,
  ClientMessage_MessageType_ICE_SERVICE = 5,
  ClientMessage_MessageType_ICE_SHAKE = 6,
  ClientMessage_MessageType_ICE_SDP = 7,
  ClientMessage_MessageType_ICE_KEEPALIVE = 8,
  ClientMessage_MessageType_SHORT_CODE = 9,
  ClientMessage_MessageType_MSG_REPLY = 10,
  ClientMessage_MessageType_SDP_ACK = 11,
  ClientMessage_MessageType_GROUP_CHAT_INVITE = 12,
  ClientMessage_MessageType_GROUP_USER_MESSAGE = 13,
  ClientMessage_MessageType_GROUP_CHAT_INVITE_REPLY = 14,
  ClientMessage_MessageType_SENDFILE_ICE_SDP = 15,
  ClientMessage_MessageType_ONE_OID_MESSAGE = 16,
  ClientMessage_MessageType_MULTI_OID_MESSAGE = 17
};
bool ClientMessage_MessageType_IsValid(int value);
const ClientMessage_MessageType ClientMessage_MessageType_MessageType_MIN = ClientMessage_MessageType_USER_MESSAGE;
const ClientMessage_MessageType ClientMessage_MessageType_MessageType_MAX = ClientMessage_MessageType_MULTI_OID_MESSAGE;
const int ClientMessage_MessageType_MessageType_ARRAYSIZE = ClientMessage_MessageType_MessageType_MAX + 1;

enum IceKeepalive_MessageType {
  IceKeepalive_MessageType_PING = 0,
  IceKeepalive_MessageType_PONG = 1
};
bool IceKeepalive_MessageType_IsValid(int value);
const IceKeepalive_MessageType IceKeepalive_MessageType_MessageType_MIN = IceKeepalive_MessageType_PING;
const IceKeepalive_MessageType IceKeepalive_MessageType_MessageType_MAX = IceKeepalive_MessageType_PONG;
const int IceKeepalive_MessageType_MessageType_ARRAYSIZE = IceKeepalive_MessageType_MessageType_MAX + 1;

enum IceHandleShake_MessageType {
  IceHandleShake_MessageType_SHARK = 1,
  IceHandleShake_MessageType_SHARK_ACK = 2
};
bool IceHandleShake_MessageType_IsValid(int value);
const IceHandleShake_MessageType IceHandleShake_MessageType_MessageType_MIN = IceHandleShake_MessageType_SHARK;
const IceHandleShake_MessageType IceHandleShake_MessageType_MessageType_MAX = IceHandleShake_MessageType_SHARK_ACK;
const int IceHandleShake_MessageType_MessageType_ARRAYSIZE = IceHandleShake_MessageType_MessageType_MAX + 1;

enum IceSdp_MessageType {
  IceSdp_MessageType_ICE_SRV_SDP = 1,
  IceSdp_MessageType_ICE_SDP = 2
};
bool IceSdp_MessageType_IsValid(int value);
const IceSdp_MessageType IceSdp_MessageType_MessageType_MIN = IceSdp_MessageType_ICE_SRV_SDP;
const IceSdp_MessageType IceSdp_MessageType_MessageType_MAX = IceSdp_MessageType_ICE_SDP;
const int IceSdp_MessageType_MessageType_ARRAYSIZE = IceSdp_MessageType_MessageType_MAX + 1;

enum DirectConnectionMessage_MessageType {
  DirectConnectionMessage_MessageType_ADD_FRIEND_REQUEST = 1,
  DirectConnectionMessage_MessageType_ADD_FRIEND_REPLY = 2,
  DirectConnectionMessage_MessageType_USER_MESSAGE = 3,
  DirectConnectionMessage_MessageType_NOTIFY_DELETE = 4
};
bool DirectConnectionMessage_MessageType_IsValid(int value);
const DirectConnectionMessage_MessageType DirectConnectionMessage_MessageType_MessageType_MIN = DirectConnectionMessage_MessageType_ADD_FRIEND_REQUEST;
const DirectConnectionMessage_MessageType DirectConnectionMessage_MessageType_MessageType_MAX = DirectConnectionMessage_MessageType_NOTIFY_DELETE;
const int DirectConnectionMessage_MessageType_MessageType_ARRAYSIZE = DirectConnectionMessage_MessageType_MessageType_MAX + 1;

// ===================================================================

class ClientMessage : public ::google::protobuf::MessageLite {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientMessage* other);

  // implements Message ----------------------------------------------

  ClientMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientMessage_MessageType MessageType;
  static const MessageType USER_MESSAGE = ClientMessage_MessageType_USER_MESSAGE;
  static const MessageType USER_MESSAGE_ACK = ClientMessage_MessageType_USER_MESSAGE_ACK;
  static const MessageType FRIEND_REQUEST = ClientMessage_MessageType_FRIEND_REQUEST;
  static const MessageType FRIEND_REQUEST_REPLY = ClientMessage_MessageType_FRIEND_REQUEST_REPLY;
  static const MessageType NOTIFY_FRIEND_DELETE = ClientMessage_MessageType_NOTIFY_FRIEND_DELETE;
  static const MessageType ICE_SERVICE = ClientMessage_MessageType_ICE_SERVICE;
  static const MessageType ICE_SHAKE = ClientMessage_MessageType_ICE_SHAKE;
  static const MessageType ICE_SDP = ClientMessage_MessageType_ICE_SDP;
  static const MessageType ICE_KEEPALIVE = ClientMessage_MessageType_ICE_KEEPALIVE;
  static const MessageType SHORT_CODE = ClientMessage_MessageType_SHORT_CODE;
  static const MessageType MSG_REPLY = ClientMessage_MessageType_MSG_REPLY;
  static const MessageType SDP_ACK = ClientMessage_MessageType_SDP_ACK;
  static const MessageType GROUP_CHAT_INVITE = ClientMessage_MessageType_GROUP_CHAT_INVITE;
  static const MessageType GROUP_USER_MESSAGE = ClientMessage_MessageType_GROUP_USER_MESSAGE;
  static const MessageType GROUP_CHAT_INVITE_REPLY = ClientMessage_MessageType_GROUP_CHAT_INVITE_REPLY;
  static const MessageType SENDFILE_ICE_SDP = ClientMessage_MessageType_SENDFILE_ICE_SDP;
  static const MessageType ONE_OID_MESSAGE = ClientMessage_MessageType_ONE_OID_MESSAGE;
  static const MessageType MULTI_OID_MESSAGE = ClientMessage_MessageType_MULTI_OID_MESSAGE;
  static inline bool MessageType_IsValid(int value) {
    return ClientMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    ClientMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    ClientMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    ClientMessage_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .peersafe.imapi.protobuf.ClientMessage.MessageType message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::peersafe::imapi::protobuf::ClientMessage_MessageType message_type() const;
  inline void set_message_type(::peersafe::imapi::protobuf::ClientMessage_MessageType value);

  // optional uint64 message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint64 message_id() const;
  inline void set_message_id(::google::protobuf::uint64 value);

  // optional bytes message_data = 3;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 3;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.ClientMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_message_data();
  inline void clear_has_message_data();

  ::google::protobuf::uint64 message_id_;
  ::std::string* message_data_;
  int message_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class OidMessage : public ::google::protobuf::MessageLite {
 public:
  OidMessage();
  virtual ~OidMessage();

  OidMessage(const OidMessage& from);

  inline OidMessage& operator=(const OidMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const OidMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OidMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OidMessage* other);

  // implements Message ----------------------------------------------

  OidMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OidMessage& from);
  void MergeFrom(const OidMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline const ::std::string& oid() const;
  inline void set_oid(const ::std::string& value);
  inline void set_oid(const char* value);
  inline void set_oid(const void* value, size_t size);
  inline ::std::string* mutable_oid();
  inline ::std::string* release_oid();
  inline void set_allocated_oid(::std::string* oid);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional int32 data_type = 4;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.OidMessage)
 private:
  inline void set_has_oid();
  inline void clear_has_oid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_data_type();
  inline void clear_has_data_type();

  ::std::string* oid_;
  ::std::string* value_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 data_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static OidMessage* default_instance_;
};
// -------------------------------------------------------------------

class MultiOidMessage : public ::google::protobuf::MessageLite {
 public:
  MultiOidMessage();
  virtual ~MultiOidMessage();

  MultiOidMessage(const MultiOidMessage& from);

  inline MultiOidMessage& operator=(const MultiOidMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const MultiOidMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MultiOidMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MultiOidMessage* other);

  // implements Message ----------------------------------------------

  MultiOidMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MultiOidMessage& from);
  void MergeFrom(const MultiOidMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .peersafe.imapi.protobuf.OidMessage oidmsg = 1;
  inline int oidmsg_size() const;
  inline void clear_oidmsg();
  static const int kOidmsgFieldNumber = 1;
  inline const ::peersafe::imapi::protobuf::OidMessage& oidmsg(int index) const;
  inline ::peersafe::imapi::protobuf::OidMessage* mutable_oidmsg(int index);
  inline ::peersafe::imapi::protobuf::OidMessage* add_oidmsg();
  inline const ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::OidMessage >&
      oidmsg() const;
  inline ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::OidMessage >*
      mutable_oidmsg();

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.MultiOidMessage)
 private:

  ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::OidMessage > oidmsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static MultiOidMessage* default_instance_;
};
// -------------------------------------------------------------------

class SyncMessage : public ::google::protobuf::MessageLite {
 public:
  SyncMessage();
  virtual ~SyncMessage();

  SyncMessage(const SyncMessage& from);

  inline SyncMessage& operator=(const SyncMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SyncMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncMessage* other);

  // implements Message ----------------------------------------------

  SyncMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncMessage& from);
  void MergeFrom(const SyncMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 message_type() const;
  inline void set_message_type(::google::protobuf::int32 value);

  // optional bytes channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // optional bytes message_data = 3;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 3;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // optional uint32 expire = 4;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 4;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional uint32 entire_expire = 5;
  inline bool has_entire_expire() const;
  inline void clear_entire_expire();
  static const int kEntireExpireFieldNumber = 5;
  inline ::google::protobuf::uint32 entire_expire() const;
  inline void set_entire_expire(::google::protobuf::uint32 value);

  // optional uint32 length = 6;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 6;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 7;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.SyncMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_message_data();
  inline void clear_has_message_data();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_entire_expire();
  inline void clear_has_entire_expire();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::std::string* channel_id_;
  ::google::protobuf::int32 message_type_;
  ::google::protobuf::uint32 expire_;
  ::std::string* message_data_;
  ::google::protobuf::uint32 entire_expire_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static SyncMessage* default_instance_;
};
// -------------------------------------------------------------------

class UserMessage : public ::google::protobuf::MessageLite {
 public:
  UserMessage();
  virtual ~UserMessage();

  UserMessage(const UserMessage& from);

  inline UserMessage& operator=(const UserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserMessage* other);

  // implements Message ----------------------------------------------

  UserMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserMessage& from);
  void MergeFrom(const UserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 message_type() const;
  inline void set_message_type(::google::protobuf::int32 value);

  // optional bytes message_data = 2;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 2;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // optional uint32 expire = 3;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 3;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional uint32 entire_expire = 4;
  inline bool has_entire_expire() const;
  inline void clear_entire_expire();
  static const int kEntireExpireFieldNumber = 4;
  inline ::google::protobuf::uint32 entire_expire() const;
  inline void set_entire_expire(::google::protobuf::uint32 value);

  // optional uint32 length = 5;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 device_type = 7;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 device_type() const;
  inline void set_device_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.UserMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_message_data();
  inline void clear_has_message_data();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_entire_expire();
  inline void clear_has_entire_expire();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_device_type();
  inline void clear_has_device_type();

  ::std::string* message_data_;
  ::google::protobuf::int32 message_type_;
  ::google::protobuf::uint32 expire_;
  ::google::protobuf::uint32 entire_expire_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 device_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static UserMessage* default_instance_;
};
// -------------------------------------------------------------------

class UserMessageReply : public ::google::protobuf::MessageLite {
 public:
  UserMessageReply();
  virtual ~UserMessageReply();

  UserMessageReply(const UserMessageReply& from);

  inline UserMessageReply& operator=(const UserMessageReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserMessageReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserMessageReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserMessageReply* other);

  // implements Message ----------------------------------------------

  UserMessageReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserMessageReply& from);
  void MergeFrom(const UserMessageReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint64 message_id() const;
  inline void set_message_id(::google::protobuf::uint64 value);

  // optional bytes channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.UserMessageReply)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::google::protobuf::uint64 message_id_;
  ::std::string* channel_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static UserMessageReply* default_instance_;
};
// -------------------------------------------------------------------

class IceKeepalive : public ::google::protobuf::MessageLite {
 public:
  IceKeepalive();
  virtual ~IceKeepalive();

  IceKeepalive(const IceKeepalive& from);

  inline IceKeepalive& operator=(const IceKeepalive& from) {
    CopyFrom(from);
    return *this;
  }

  static const IceKeepalive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IceKeepalive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IceKeepalive* other);

  // implements Message ----------------------------------------------

  IceKeepalive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IceKeepalive& from);
  void MergeFrom(const IceKeepalive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef IceKeepalive_MessageType MessageType;
  static const MessageType PING = IceKeepalive_MessageType_PING;
  static const MessageType PONG = IceKeepalive_MessageType_PONG;
  static inline bool MessageType_IsValid(int value) {
    return IceKeepalive_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    IceKeepalive_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    IceKeepalive_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    IceKeepalive_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .peersafe.imapi.protobuf.IceKeepalive.MessageType message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::peersafe::imapi::protobuf::IceKeepalive_MessageType message_type() const;
  inline void set_message_type(::peersafe::imapi::protobuf::IceKeepalive_MessageType value);

  // required bytes random = 2;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 2;
  inline const ::std::string& random() const;
  inline void set_random(const ::std::string& value);
  inline void set_random(const char* value);
  inline void set_random(const void* value, size_t size);
  inline ::std::string* mutable_random();
  inline ::std::string* release_random();
  inline void set_allocated_random(::std::string* random);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.IceKeepalive)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_random();
  inline void clear_has_random();

  ::std::string* random_;
  int message_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static IceKeepalive* default_instance_;
};
// -------------------------------------------------------------------

class FriendRequest : public ::google::protobuf::MessageLite {
 public:
  FriendRequest();
  virtual ~FriendRequest();

  FriendRequest(const FriendRequest& from);

  inline FriendRequest& operator=(const FriendRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendRequest* other);

  // implements Message ----------------------------------------------

  FriendRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendRequest& from);
  void MergeFrom(const FriendRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes channel_public_key = 1;
  inline bool has_channel_public_key() const;
  inline void clear_channel_public_key();
  static const int kChannelPublicKeyFieldNumber = 1;
  inline const ::std::string& channel_public_key() const;
  inline void set_channel_public_key(const ::std::string& value);
  inline void set_channel_public_key(const char* value);
  inline void set_channel_public_key(const void* value, size_t size);
  inline ::std::string* mutable_channel_public_key();
  inline ::std::string* release_channel_public_key();
  inline void set_allocated_channel_public_key(::std::string* channel_public_key);

  // required bytes channel_private_key = 2;
  inline bool has_channel_private_key() const;
  inline void clear_channel_private_key();
  static const int kChannelPrivateKeyFieldNumber = 2;
  inline const ::std::string& channel_private_key() const;
  inline void set_channel_private_key(const ::std::string& value);
  inline void set_channel_private_key(const char* value);
  inline void set_channel_private_key(const void* value, size_t size);
  inline ::std::string* mutable_channel_private_key();
  inline ::std::string* release_channel_private_key();
  inline void set_allocated_channel_private_key(::std::string* channel_private_key);

  // required bytes session_public_key = 3;
  inline bool has_session_public_key() const;
  inline void clear_session_public_key();
  static const int kSessionPublicKeyFieldNumber = 3;
  inline const ::std::string& session_public_key() const;
  inline void set_session_public_key(const ::std::string& value);
  inline void set_session_public_key(const char* value);
  inline void set_session_public_key(const void* value, size_t size);
  inline ::std::string* mutable_session_public_key();
  inline ::std::string* release_session_public_key();
  inline void set_allocated_session_public_key(::std::string* session_public_key);

  // required bytes info = 4;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 4;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // required bytes flags = 5;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 5;
  inline const ::std::string& flags() const;
  inline void set_flags(const ::std::string& value);
  inline void set_flags(const char* value);
  inline void set_flags(const void* value, size_t size);
  inline ::std::string* mutable_flags();
  inline ::std::string* release_flags();
  inline void set_allocated_flags(::std::string* flags);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.FriendRequest)
 private:
  inline void set_has_channel_public_key();
  inline void clear_has_channel_public_key();
  inline void set_has_channel_private_key();
  inline void clear_has_channel_private_key();
  inline void set_has_session_public_key();
  inline void clear_has_session_public_key();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::std::string* channel_public_key_;
  ::std::string* channel_private_key_;
  ::std::string* session_public_key_;
  ::std::string* info_;
  ::std::string* flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static FriendRequest* default_instance_;
};
// -------------------------------------------------------------------

class FriendReply : public ::google::protobuf::MessageLite {
 public:
  FriendReply();
  virtual ~FriendReply();

  FriendReply(const FriendReply& from);

  inline FriendReply& operator=(const FriendReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendReply* other);

  // implements Message ----------------------------------------------

  FriendReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendReply& from);
  void MergeFrom(const FriendReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool accepted = 1;
  inline bool has_accepted() const;
  inline void clear_accepted();
  static const int kAcceptedFieldNumber = 1;
  inline bool accepted() const;
  inline void set_accepted(bool value);

  // optional bytes session_public_key = 2;
  inline bool has_session_public_key() const;
  inline void clear_session_public_key();
  static const int kSessionPublicKeyFieldNumber = 2;
  inline const ::std::string& session_public_key() const;
  inline void set_session_public_key(const ::std::string& value);
  inline void set_session_public_key(const char* value);
  inline void set_session_public_key(const void* value, size_t size);
  inline ::std::string* mutable_session_public_key();
  inline ::std::string* release_session_public_key();
  inline void set_allocated_session_public_key(::std::string* session_public_key);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.FriendReply)
 private:
  inline void set_has_accepted();
  inline void clear_has_accepted();
  inline void set_has_session_public_key();
  inline void clear_has_session_public_key();

  ::std::string* session_public_key_;
  bool accepted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static FriendReply* default_instance_;
};
// -------------------------------------------------------------------

class IceService : public ::google::protobuf::MessageLite {
 public:
  IceService();
  virtual ~IceService();

  IceService(const IceService& from);

  inline IceService& operator=(const IceService& from) {
    CopyFrom(from);
    return *this;
  }

  static const IceService& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IceService* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IceService* other);

  // implements Message ----------------------------------------------

  IceService* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IceService& from);
  void MergeFrom(const IceService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const void* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required bytes uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required bytes pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const void* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.IceService)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::std::string* host_;
  ::std::string* uid_;
  ::std::string* pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static IceService* default_instance_;
};
// -------------------------------------------------------------------

class IceServiceCache : public ::google::protobuf::MessageLite {
 public:
  IceServiceCache();
  virtual ~IceServiceCache();

  IceServiceCache(const IceServiceCache& from);

  inline IceServiceCache& operator=(const IceServiceCache& from) {
    CopyFrom(from);
    return *this;
  }

  static const IceServiceCache& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IceServiceCache* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IceServiceCache* other);

  // implements Message ----------------------------------------------

  IceServiceCache* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IceServiceCache& from);
  void MergeFrom(const IceServiceCache& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .peersafe.imapi.protobuf.IceService items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::peersafe::imapi::protobuf::IceService& items(int index) const;
  inline ::peersafe::imapi::protobuf::IceService* mutable_items(int index);
  inline ::peersafe::imapi::protobuf::IceService* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::IceService >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::IceService >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.IceServiceCache)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::IceService > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static IceServiceCache* default_instance_;
};
// -------------------------------------------------------------------

class IceHandleShake : public ::google::protobuf::MessageLite {
 public:
  IceHandleShake();
  virtual ~IceHandleShake();

  IceHandleShake(const IceHandleShake& from);

  inline IceHandleShake& operator=(const IceHandleShake& from) {
    CopyFrom(from);
    return *this;
  }

  static const IceHandleShake& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IceHandleShake* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IceHandleShake* other);

  // implements Message ----------------------------------------------

  IceHandleShake* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IceHandleShake& from);
  void MergeFrom(const IceHandleShake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef IceHandleShake_MessageType MessageType;
  static const MessageType SHARK = IceHandleShake_MessageType_SHARK;
  static const MessageType SHARK_ACK = IceHandleShake_MessageType_SHARK_ACK;
  static inline bool MessageType_IsValid(int value) {
    return IceHandleShake_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    IceHandleShake_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    IceHandleShake_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    IceHandleShake_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .peersafe.imapi.protobuf.IceHandleShake.MessageType message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::peersafe::imapi::protobuf::IceHandleShake_MessageType message_type() const;
  inline void set_message_type(::peersafe::imapi::protobuf::IceHandleShake_MessageType value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.IceHandleShake)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();

  int message_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static IceHandleShake* default_instance_;
};
// -------------------------------------------------------------------

class IceSdp : public ::google::protobuf::MessageLite {
 public:
  IceSdp();
  virtual ~IceSdp();

  IceSdp(const IceSdp& from);

  inline IceSdp& operator=(const IceSdp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IceSdp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IceSdp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IceSdp* other);

  // implements Message ----------------------------------------------

  IceSdp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IceSdp& from);
  void MergeFrom(const IceSdp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef IceSdp_MessageType MessageType;
  static const MessageType ICE_SRV_SDP = IceSdp_MessageType_ICE_SRV_SDP;
  static const MessageType ICE_SDP = IceSdp_MessageType_ICE_SDP;
  static inline bool MessageType_IsValid(int value) {
    return IceSdp_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    IceSdp_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    IceSdp_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    IceSdp_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .peersafe.imapi.protobuf.IceSdp.MessageType message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::peersafe::imapi::protobuf::IceSdp_MessageType message_type() const;
  inline void set_message_type(::peersafe::imapi::protobuf::IceSdp_MessageType value);

  // required bytes sdp = 2;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 2;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const void* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // optional .peersafe.imapi.protobuf.IceService ice_srv = 3;
  inline bool has_ice_srv() const;
  inline void clear_ice_srv();
  static const int kIceSrvFieldNumber = 3;
  inline const ::peersafe::imapi::protobuf::IceService& ice_srv() const;
  inline ::peersafe::imapi::protobuf::IceService* mutable_ice_srv();
  inline ::peersafe::imapi::protobuf::IceService* release_ice_srv();
  inline void set_allocated_ice_srv(::peersafe::imapi::protobuf::IceService* ice_srv);

  // optional int32 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.IceSdp)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_ice_srv();
  inline void clear_has_ice_srv();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* sdp_;
  int message_type_;
  ::google::protobuf::int32 version_;
  ::peersafe::imapi::protobuf::IceService* ice_srv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static IceSdp* default_instance_;
};
// -------------------------------------------------------------------

class ChannelMessage : public ::google::protobuf::MessageLite {
 public:
  ChannelMessage();
  virtual ~ChannelMessage();

  ChannelMessage(const ChannelMessage& from);

  inline ChannelMessage& operator=(const ChannelMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChannelMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChannelMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChannelMessage* other);

  // implements Message ----------------------------------------------

  ChannelMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChannelMessage& from);
  void MergeFrom(const ChannelMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool encrypted = 1;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 1;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.ChannelMessage)
 private:
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string* data_;
  bool encrypted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static ChannelMessage* default_instance_;
};
// -------------------------------------------------------------------

class DirectConnectionMessage : public ::google::protobuf::MessageLite {
 public:
  DirectConnectionMessage();
  virtual ~DirectConnectionMessage();

  DirectConnectionMessage(const DirectConnectionMessage& from);

  inline DirectConnectionMessage& operator=(const DirectConnectionMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectConnectionMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectConnectionMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectConnectionMessage* other);

  // implements Message ----------------------------------------------

  DirectConnectionMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectConnectionMessage& from);
  void MergeFrom(const DirectConnectionMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DirectConnectionMessage_MessageType MessageType;
  static const MessageType ADD_FRIEND_REQUEST = DirectConnectionMessage_MessageType_ADD_FRIEND_REQUEST;
  static const MessageType ADD_FRIEND_REPLY = DirectConnectionMessage_MessageType_ADD_FRIEND_REPLY;
  static const MessageType USER_MESSAGE = DirectConnectionMessage_MessageType_USER_MESSAGE;
  static const MessageType NOTIFY_DELETE = DirectConnectionMessage_MessageType_NOTIFY_DELETE;
  static inline bool MessageType_IsValid(int value) {
    return DirectConnectionMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    DirectConnectionMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    DirectConnectionMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    DirectConnectionMessage_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .peersafe.imapi.protobuf.DirectConnectionMessage.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::peersafe::imapi::protobuf::DirectConnectionMessage_MessageType type() const;
  inline void set_type(::peersafe::imapi::protobuf::DirectConnectionMessage_MessageType value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // required bytes friend_channel_id = 3;
  inline bool has_friend_channel_id() const;
  inline void clear_friend_channel_id();
  static const int kFriendChannelIdFieldNumber = 3;
  inline const ::std::string& friend_channel_id() const;
  inline void set_friend_channel_id(const ::std::string& value);
  inline void set_friend_channel_id(const char* value);
  inline void set_friend_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_channel_id();
  inline ::std::string* release_friend_channel_id();
  inline void set_allocated_friend_channel_id(::std::string* friend_channel_id);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.DirectConnectionMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_friend_channel_id();
  inline void clear_has_friend_channel_id();

  ::std::string* data_;
  ::std::string* friend_channel_id_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static DirectConnectionMessage* default_instance_;
};
// -------------------------------------------------------------------

class GroupChatInvite : public ::google::protobuf::MessageLite {
 public:
  GroupChatInvite();
  virtual ~GroupChatInvite();

  GroupChatInvite(const GroupChatInvite& from);

  inline GroupChatInvite& operator=(const GroupChatInvite& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupChatInvite& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChatInvite* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChatInvite* other);

  // implements Message ----------------------------------------------

  GroupChatInvite* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChatInvite& from);
  void MergeFrom(const GroupChatInvite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes group_public_key = 1;
  inline bool has_group_public_key() const;
  inline void clear_group_public_key();
  static const int kGroupPublicKeyFieldNumber = 1;
  inline const ::std::string& group_public_key() const;
  inline void set_group_public_key(const ::std::string& value);
  inline void set_group_public_key(const char* value);
  inline void set_group_public_key(const void* value, size_t size);
  inline ::std::string* mutable_group_public_key();
  inline ::std::string* release_group_public_key();
  inline void set_allocated_group_public_key(::std::string* group_public_key);

  // required bytes group_private_key = 2;
  inline bool has_group_private_key() const;
  inline void clear_group_private_key();
  static const int kGroupPrivateKeyFieldNumber = 2;
  inline const ::std::string& group_private_key() const;
  inline void set_group_private_key(const ::std::string& value);
  inline void set_group_private_key(const char* value);
  inline void set_group_private_key(const void* value, size_t size);
  inline ::std::string* mutable_group_private_key();
  inline ::std::string* release_group_private_key();
  inline void set_allocated_group_private_key(::std::string* group_private_key);

  // required bytes info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupChatInvite)
 private:
  inline void set_has_group_public_key();
  inline void clear_has_group_public_key();
  inline void set_has_group_private_key();
  inline void clear_has_group_private_key();
  inline void set_has_info();
  inline void clear_has_info();

  ::std::string* group_public_key_;
  ::std::string* group_private_key_;
  ::std::string* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupChatInvite* default_instance_;
};
// -------------------------------------------------------------------

class GroupChatInviteReply : public ::google::protobuf::MessageLite {
 public:
  GroupChatInviteReply();
  virtual ~GroupChatInviteReply();

  GroupChatInviteReply(const GroupChatInviteReply& from);

  inline GroupChatInviteReply& operator=(const GroupChatInviteReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupChatInviteReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChatInviteReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChatInviteReply* other);

  // implements Message ----------------------------------------------

  GroupChatInviteReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChatInviteReply& from);
  void MergeFrom(const GroupChatInviteReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool accepted = 1;
  inline bool has_accepted() const;
  inline void clear_accepted();
  static const int kAcceptedFieldNumber = 1;
  inline bool accepted() const;
  inline void set_accepted(bool value);

  // required bytes info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // required bytes group_channel_id = 3;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 3;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupChatInviteReply)
 private:
  inline void set_has_accepted();
  inline void clear_has_accepted();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();

  ::std::string* info_;
  ::std::string* group_channel_id_;
  bool accepted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupChatInviteReply* default_instance_;
};
// -------------------------------------------------------------------

class GroupUserMessage : public ::google::protobuf::MessageLite {
 public:
  GroupUserMessage();
  virtual ~GroupUserMessage();

  GroupUserMessage(const GroupUserMessage& from);

  inline GroupUserMessage& operator=(const GroupUserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupUserMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUserMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUserMessage* other);

  // implements Message ----------------------------------------------

  GroupUserMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUserMessage& from);
  void MergeFrom(const GroupUserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 message_type() const;
  inline void set_message_type(::google::protobuf::int32 value);

  // optional bytes message_data = 2;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 2;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // optional uint32 expire = 3;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 3;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional uint32 entire_expire = 4;
  inline bool has_entire_expire() const;
  inline void clear_entire_expire();
  static const int kEntireExpireFieldNumber = 4;
  inline ::google::protobuf::uint32 entire_expire() const;
  inline void set_entire_expire(::google::protobuf::uint32 value);

  // optional uint32 length = 5;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // required bytes info = 7;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 7;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // optional uint32 device_type = 8;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 device_type() const;
  inline void set_device_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupUserMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_message_data();
  inline void clear_has_message_data();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_entire_expire();
  inline void clear_has_entire_expire();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_device_type();
  inline void clear_has_device_type();

  ::std::string* message_data_;
  ::google::protobuf::int32 message_type_;
  ::google::protobuf::uint32 expire_;
  ::google::protobuf::uint32 entire_expire_;
  ::google::protobuf::uint32 length_;
  ::std::string* info_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 device_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupUserMessage* default_instance_;
};
// -------------------------------------------------------------------

class GroupChannelData : public ::google::protobuf::MessageLite {
 public:
  GroupChannelData();
  virtual ~GroupChannelData();

  GroupChannelData(const GroupChannelData& from);

  inline GroupChannelData& operator=(const GroupChannelData& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupChannelData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChannelData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChannelData* other);

  // implements Message ----------------------------------------------

  GroupChannelData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChannelData& from);
  void MergeFrom(const GroupChannelData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // required uint64 create = 2;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 2;
  inline ::google::protobuf::uint64 create() const;
  inline void set_create(::google::protobuf::uint64 value);

  // required uint64 expire = 3;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 3;
  inline ::google::protobuf::uint64 expire() const;
  inline void set_expire(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupChannelData)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_expire();
  inline void clear_has_expire();

  ::std::string* data_;
  ::google::protobuf::uint64 create_;
  ::google::protobuf::uint64 expire_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupChannelData* default_instance_;
};
// -------------------------------------------------------------------

class GroupChannelDatas : public ::google::protobuf::MessageLite {
 public:
  GroupChannelDatas();
  virtual ~GroupChannelDatas();

  GroupChannelDatas(const GroupChannelDatas& from);

  inline GroupChannelDatas& operator=(const GroupChannelDatas& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupChannelDatas& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChannelDatas* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChannelDatas* other);

  // implements Message ----------------------------------------------

  GroupChannelDatas* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChannelDatas& from);
  void MergeFrom(const GroupChannelDatas& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .peersafe.imapi.protobuf.GroupChannelData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::peersafe::imapi::protobuf::GroupChannelData& data(int index) const;
  inline ::peersafe::imapi::protobuf::GroupChannelData* mutable_data(int index);
  inline ::peersafe::imapi::protobuf::GroupChannelData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::GroupChannelData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::GroupChannelData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupChannelDatas)
 private:

  ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::GroupChannelData > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupChannelDatas* default_instance_;
};
// -------------------------------------------------------------------

class GroupSyncChatInvite : public ::google::protobuf::MessageLite {
 public:
  GroupSyncChatInvite();
  virtual ~GroupSyncChatInvite();

  GroupSyncChatInvite(const GroupSyncChatInvite& from);

  inline GroupSyncChatInvite& operator=(const GroupSyncChatInvite& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupSyncChatInvite& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupSyncChatInvite* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupSyncChatInvite* other);

  // implements Message ----------------------------------------------

  GroupSyncChatInvite* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupSyncChatInvite& from);
  void MergeFrom(const GroupSyncChatInvite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes friend_channel_id = 1;
  inline bool has_friend_channel_id() const;
  inline void clear_friend_channel_id();
  static const int kFriendChannelIdFieldNumber = 1;
  inline const ::std::string& friend_channel_id() const;
  inline void set_friend_channel_id(const ::std::string& value);
  inline void set_friend_channel_id(const char* value);
  inline void set_friend_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_channel_id();
  inline ::std::string* release_friend_channel_id();
  inline void set_allocated_friend_channel_id(::std::string* friend_channel_id);

  // required bytes group_channel_id = 2;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 2;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // required bytes my_name = 3;
  inline bool has_my_name() const;
  inline void clear_my_name();
  static const int kMyNameFieldNumber = 3;
  inline const ::std::string& my_name() const;
  inline void set_my_name(const ::std::string& value);
  inline void set_my_name(const char* value);
  inline void set_my_name(const void* value, size_t size);
  inline ::std::string* mutable_my_name();
  inline ::std::string* release_my_name();
  inline void set_allocated_my_name(::std::string* my_name);

  // required bytes group_public_key = 4;
  inline bool has_group_public_key() const;
  inline void clear_group_public_key();
  static const int kGroupPublicKeyFieldNumber = 4;
  inline const ::std::string& group_public_key() const;
  inline void set_group_public_key(const ::std::string& value);
  inline void set_group_public_key(const char* value);
  inline void set_group_public_key(const void* value, size_t size);
  inline ::std::string* mutable_group_public_key();
  inline ::std::string* release_group_public_key();
  inline void set_allocated_group_public_key(::std::string* group_public_key);

  // required bytes group_private_key = 5;
  inline bool has_group_private_key() const;
  inline void clear_group_private_key();
  static const int kGroupPrivateKeyFieldNumber = 5;
  inline const ::std::string& group_private_key() const;
  inline void set_group_private_key(const ::std::string& value);
  inline void set_group_private_key(const char* value);
  inline void set_group_private_key(const void* value, size_t size);
  inline ::std::string* mutable_group_private_key();
  inline ::std::string* release_group_private_key();
  inline void set_allocated_group_private_key(::std::string* group_private_key);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupSyncChatInvite)
 private:
  inline void set_has_friend_channel_id();
  inline void clear_has_friend_channel_id();
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();
  inline void set_has_my_name();
  inline void clear_has_my_name();
  inline void set_has_group_public_key();
  inline void clear_has_group_public_key();
  inline void set_has_group_private_key();
  inline void clear_has_group_private_key();

  ::std::string* friend_channel_id_;
  ::std::string* group_channel_id_;
  ::std::string* my_name_;
  ::std::string* group_public_key_;
  ::std::string* group_private_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupSyncChatInvite* default_instance_;
};
// -------------------------------------------------------------------

class GroupSyncChatInviteReply : public ::google::protobuf::MessageLite {
 public:
  GroupSyncChatInviteReply();
  virtual ~GroupSyncChatInviteReply();

  GroupSyncChatInviteReply(const GroupSyncChatInviteReply& from);

  inline GroupSyncChatInviteReply& operator=(const GroupSyncChatInviteReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupSyncChatInviteReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupSyncChatInviteReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupSyncChatInviteReply* other);

  // implements Message ----------------------------------------------

  GroupSyncChatInviteReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupSyncChatInviteReply& from);
  void MergeFrom(const GroupSyncChatInviteReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes friend_channel_id = 1;
  inline bool has_friend_channel_id() const;
  inline void clear_friend_channel_id();
  static const int kFriendChannelIdFieldNumber = 1;
  inline const ::std::string& friend_channel_id() const;
  inline void set_friend_channel_id(const ::std::string& value);
  inline void set_friend_channel_id(const char* value);
  inline void set_friend_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_channel_id();
  inline ::std::string* release_friend_channel_id();
  inline void set_allocated_friend_channel_id(::std::string* friend_channel_id);

  // required bytes group_channel_id = 2;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 2;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // required bool accepted = 3;
  inline bool has_accepted() const;
  inline void clear_accepted();
  static const int kAcceptedFieldNumber = 3;
  inline bool accepted() const;
  inline void set_accepted(bool value);

  // required bytes friend_member_id = 4;
  inline bool has_friend_member_id() const;
  inline void clear_friend_member_id();
  static const int kFriendMemberIdFieldNumber = 4;
  inline const ::std::string& friend_member_id() const;
  inline void set_friend_member_id(const ::std::string& value);
  inline void set_friend_member_id(const char* value);
  inline void set_friend_member_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_member_id();
  inline ::std::string* release_friend_member_id();
  inline void set_allocated_friend_member_id(::std::string* friend_member_id);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupSyncChatInviteReply)
 private:
  inline void set_has_friend_channel_id();
  inline void clear_has_friend_channel_id();
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();
  inline void set_has_accepted();
  inline void clear_has_accepted();
  inline void set_has_friend_member_id();
  inline void clear_has_friend_member_id();

  ::std::string* friend_channel_id_;
  ::std::string* group_channel_id_;
  ::std::string* friend_member_id_;
  bool accepted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupSyncChatInviteReply* default_instance_;
};
// -------------------------------------------------------------------

class GroupSyncNewMember : public ::google::protobuf::MessageLite {
 public:
  GroupSyncNewMember();
  virtual ~GroupSyncNewMember();

  GroupSyncNewMember(const GroupSyncNewMember& from);

  inline GroupSyncNewMember& operator=(const GroupSyncNewMember& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupSyncNewMember& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupSyncNewMember* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupSyncNewMember* other);

  // implements Message ----------------------------------------------

  GroupSyncNewMember* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupSyncNewMember& from);
  void MergeFrom(const GroupSyncNewMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes group_channel_id = 1;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 1;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // required bytes friend_member_id = 2;
  inline bool has_friend_member_id() const;
  inline void clear_friend_member_id();
  static const int kFriendMemberIdFieldNumber = 2;
  inline const ::std::string& friend_member_id() const;
  inline void set_friend_member_id(const ::std::string& value);
  inline void set_friend_member_id(const char* value);
  inline void set_friend_member_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_member_id();
  inline ::std::string* release_friend_member_id();
  inline void set_allocated_friend_member_id(::std::string* friend_member_id);

  // required bytes friend_name = 3;
  inline bool has_friend_name() const;
  inline void clear_friend_name();
  static const int kFriendNameFieldNumber = 3;
  inline const ::std::string& friend_name() const;
  inline void set_friend_name(const ::std::string& value);
  inline void set_friend_name(const char* value);
  inline void set_friend_name(const void* value, size_t size);
  inline ::std::string* mutable_friend_name();
  inline ::std::string* release_friend_name();
  inline void set_allocated_friend_name(::std::string* friend_name);

  // required uint64 join_time = 4;
  inline bool has_join_time() const;
  inline void clear_join_time();
  static const int kJoinTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 join_time() const;
  inline void set_join_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupSyncNewMember)
 private:
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();
  inline void set_has_friend_member_id();
  inline void clear_has_friend_member_id();
  inline void set_has_friend_name();
  inline void clear_has_friend_name();
  inline void set_has_join_time();
  inline void clear_has_join_time();

  ::std::string* group_channel_id_;
  ::std::string* friend_member_id_;
  ::std::string* friend_name_;
  ::google::protobuf::uint64 join_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupSyncNewMember* default_instance_;
};
// -------------------------------------------------------------------

class GroupSyncRemoveMember : public ::google::protobuf::MessageLite {
 public:
  GroupSyncRemoveMember();
  virtual ~GroupSyncRemoveMember();

  GroupSyncRemoveMember(const GroupSyncRemoveMember& from);

  inline GroupSyncRemoveMember& operator=(const GroupSyncRemoveMember& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupSyncRemoveMember& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupSyncRemoveMember* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupSyncRemoveMember* other);

  // implements Message ----------------------------------------------

  GroupSyncRemoveMember* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupSyncRemoveMember& from);
  void MergeFrom(const GroupSyncRemoveMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes group_channel_id = 1;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 1;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // required bytes remover_id = 2;
  inline bool has_remover_id() const;
  inline void clear_remover_id();
  static const int kRemoverIdFieldNumber = 2;
  inline const ::std::string& remover_id() const;
  inline void set_remover_id(const ::std::string& value);
  inline void set_remover_id(const char* value);
  inline void set_remover_id(const void* value, size_t size);
  inline ::std::string* mutable_remover_id();
  inline ::std::string* release_remover_id();
  inline void set_allocated_remover_id(::std::string* remover_id);

  // required bytes memeber_id = 3;
  inline bool has_memeber_id() const;
  inline void clear_memeber_id();
  static const int kMemeberIdFieldNumber = 3;
  inline const ::std::string& memeber_id() const;
  inline void set_memeber_id(const ::std::string& value);
  inline void set_memeber_id(const char* value);
  inline void set_memeber_id(const void* value, size_t size);
  inline ::std::string* mutable_memeber_id();
  inline ::std::string* release_memeber_id();
  inline void set_allocated_memeber_id(::std::string* memeber_id);

  // required uint64 remove_time = 4;
  inline bool has_remove_time() const;
  inline void clear_remove_time();
  static const int kRemoveTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 remove_time() const;
  inline void set_remove_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupSyncRemoveMember)
 private:
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();
  inline void set_has_remover_id();
  inline void clear_has_remover_id();
  inline void set_has_memeber_id();
  inline void clear_has_memeber_id();
  inline void set_has_remove_time();
  inline void clear_has_remove_time();

  ::std::string* group_channel_id_;
  ::std::string* remover_id_;
  ::std::string* memeber_id_;
  ::google::protobuf::uint64 remove_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupSyncRemoveMember* default_instance_;
};
// -------------------------------------------------------------------

class GroupSyncUserMessage : public ::google::protobuf::MessageLite {
 public:
  GroupSyncUserMessage();
  virtual ~GroupSyncUserMessage();

  GroupSyncUserMessage(const GroupSyncUserMessage& from);

  inline GroupSyncUserMessage& operator=(const GroupSyncUserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupSyncUserMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupSyncUserMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupSyncUserMessage* other);

  // implements Message ----------------------------------------------

  GroupSyncUserMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupSyncUserMessage& from);
  void MergeFrom(const GroupSyncUserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes group_channel_id = 1;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 1;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // required bytes author = 2;
  inline bool has_author() const;
  inline void clear_author();
  static const int kAuthorFieldNumber = 2;
  inline const ::std::string& author() const;
  inline void set_author(const ::std::string& value);
  inline void set_author(const char* value);
  inline void set_author(const void* value, size_t size);
  inline ::std::string* mutable_author();
  inline ::std::string* release_author();
  inline void set_allocated_author(::std::string* author);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required bytes message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // required uint64 message_id = 5;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 5;
  inline ::google::protobuf::uint64 message_id() const;
  inline void set_message_id(::google::protobuf::uint64 value);

  // required uint32 expire = 6;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 6;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // required uint32 entire_expire = 7;
  inline bool has_entire_expire() const;
  inline void clear_entire_expire();
  static const int kEntireExpireFieldNumber = 7;
  inline ::google::protobuf::uint32 entire_expire() const;
  inline void set_entire_expire(::google::protobuf::uint32 value);

  // required uint32 length = 8;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 8;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // required uint32 timestamp = 9;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // required bytes author_name = 10;
  inline bool has_author_name() const;
  inline void clear_author_name();
  static const int kAuthorNameFieldNumber = 10;
  inline const ::std::string& author_name() const;
  inline void set_author_name(const ::std::string& value);
  inline void set_author_name(const char* value);
  inline void set_author_name(const void* value, size_t size);
  inline ::std::string* mutable_author_name();
  inline ::std::string* release_author_name();
  inline void set_allocated_author_name(::std::string* author_name);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupSyncUserMessage)
 private:
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();
  inline void set_has_author();
  inline void clear_has_author();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_entire_expire();
  inline void clear_has_entire_expire();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_author_name();
  inline void clear_has_author_name();

  ::std::string* group_channel_id_;
  ::std::string* author_;
  ::std::string* message_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint32 expire_;
  ::google::protobuf::uint64 message_id_;
  ::google::protobuf::uint32 entire_expire_;
  ::google::protobuf::uint32 length_;
  ::std::string* author_name_;
  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupSyncUserMessage* default_instance_;
};
// -------------------------------------------------------------------

class GroupSyncChangeName : public ::google::protobuf::MessageLite {
 public:
  GroupSyncChangeName();
  virtual ~GroupSyncChangeName();

  GroupSyncChangeName(const GroupSyncChangeName& from);

  inline GroupSyncChangeName& operator=(const GroupSyncChangeName& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupSyncChangeName& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupSyncChangeName* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupSyncChangeName* other);

  // implements Message ----------------------------------------------

  GroupSyncChangeName* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupSyncChangeName& from);
  void MergeFrom(const GroupSyncChangeName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes group_channel_id = 1;
  inline bool has_group_channel_id() const;
  inline void clear_group_channel_id();
  static const int kGroupChannelIdFieldNumber = 1;
  inline const ::std::string& group_channel_id() const;
  inline void set_group_channel_id(const ::std::string& value);
  inline void set_group_channel_id(const char* value);
  inline void set_group_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_group_channel_id();
  inline ::std::string* release_group_channel_id();
  inline void set_allocated_group_channel_id(::std::string* group_channel_id);

  // required bytes channel_name = 2;
  inline bool has_channel_name() const;
  inline void clear_channel_name();
  static const int kChannelNameFieldNumber = 2;
  inline const ::std::string& channel_name() const;
  inline void set_channel_name(const ::std::string& value);
  inline void set_channel_name(const char* value);
  inline void set_channel_name(const void* value, size_t size);
  inline ::std::string* mutable_channel_name();
  inline ::std::string* release_channel_name();
  inline void set_allocated_channel_name(::std::string* channel_name);

  // required uint64 changed_time = 3;
  inline bool has_changed_time() const;
  inline void clear_changed_time();
  static const int kChangedTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 changed_time() const;
  inline void set_changed_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:peersafe.imapi.protobuf.GroupSyncChangeName)
 private:
  inline void set_has_group_channel_id();
  inline void clear_has_group_channel_id();
  inline void set_has_channel_name();
  inline void clear_has_channel_name();
  inline void set_has_changed_time();
  inline void clear_has_changed_time();

  ::std::string* group_channel_id_;
  ::std::string* channel_name_;
  ::google::protobuf::uint64 changed_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peersafe_2fimapi_2fim_2eproto();
  #endif
  friend void protobuf_AssignDesc_peersafe_2fimapi_2fim_2eproto();
  friend void protobuf_ShutdownFile_peersafe_2fimapi_2fim_2eproto();

  void InitAsDefaultInstance();
  static GroupSyncChangeName* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientMessage

// required .peersafe.imapi.protobuf.ClientMessage.MessageType message_type = 1;
inline bool ClientMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::peersafe::imapi::protobuf::ClientMessage_MessageType ClientMessage::message_type() const {
  return static_cast< ::peersafe::imapi::protobuf::ClientMessage_MessageType >(message_type_);
}
inline void ClientMessage::set_message_type(::peersafe::imapi::protobuf::ClientMessage_MessageType value) {
  assert(::peersafe::imapi::protobuf::ClientMessage_MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// optional uint64 message_id = 2;
inline bool ClientMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_message_id() {
  message_id_ = GOOGLE_ULONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::uint64 ClientMessage::message_id() const {
  return message_id_;
}
inline void ClientMessage::set_message_id(::google::protobuf::uint64 value) {
  set_has_message_id();
  message_id_ = value;
}

// optional bytes message_data = 3;
inline bool ClientMessage::has_message_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_message_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& ClientMessage::message_data() const {
  return *message_data_;
}
inline void ClientMessage::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void ClientMessage::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void ClientMessage::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMessage::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  return message_data_;
}
inline ::std::string* ClientMessage::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientMessage::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// OidMessage

// required bytes oid = 1;
inline bool OidMessage::has_oid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OidMessage::set_has_oid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OidMessage::clear_has_oid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OidMessage::clear_oid() {
  if (oid_ != &::google::protobuf::internal::GetEmptyString()) {
    oid_->clear();
  }
  clear_has_oid();
}
inline const ::std::string& OidMessage::oid() const {
  return *oid_;
}
inline void OidMessage::set_oid(const ::std::string& value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void OidMessage::set_oid(const char* value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void OidMessage::set_oid(const void* value, size_t size) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  oid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OidMessage::mutable_oid() {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  return oid_;
}
inline ::std::string* OidMessage::release_oid() {
  clear_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = oid_;
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void OidMessage::set_allocated_oid(::std::string* oid) {
  if (oid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete oid_;
  }
  if (oid) {
    set_has_oid();
    oid_ = oid;
  } else {
    clear_has_oid();
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 type = 2;
inline bool OidMessage::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OidMessage::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OidMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OidMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 OidMessage::type() const {
  return type_;
}
inline void OidMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes value = 3;
inline bool OidMessage::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OidMessage::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OidMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OidMessage::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyString()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OidMessage::value() const {
  return *value_;
}
inline void OidMessage::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyString()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OidMessage::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyString()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OidMessage::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyString()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OidMessage::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyString()) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* OidMessage::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void OidMessage::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyString()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 data_type = 4;
inline bool OidMessage::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OidMessage::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OidMessage::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OidMessage::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::google::protobuf::int32 OidMessage::data_type() const {
  return data_type_;
}
inline void OidMessage::set_data_type(::google::protobuf::int32 value) {
  set_has_data_type();
  data_type_ = value;
}

// -------------------------------------------------------------------

// MultiOidMessage

// repeated .peersafe.imapi.protobuf.OidMessage oidmsg = 1;
inline int MultiOidMessage::oidmsg_size() const {
  return oidmsg_.size();
}
inline void MultiOidMessage::clear_oidmsg() {
  oidmsg_.Clear();
}
inline const ::peersafe::imapi::protobuf::OidMessage& MultiOidMessage::oidmsg(int index) const {
  return oidmsg_.Get(index);
}
inline ::peersafe::imapi::protobuf::OidMessage* MultiOidMessage::mutable_oidmsg(int index) {
  return oidmsg_.Mutable(index);
}
inline ::peersafe::imapi::protobuf::OidMessage* MultiOidMessage::add_oidmsg() {
  return oidmsg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::OidMessage >&
MultiOidMessage::oidmsg() const {
  return oidmsg_;
}
inline ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::OidMessage >*
MultiOidMessage::mutable_oidmsg() {
  return &oidmsg_;
}

// -------------------------------------------------------------------

// SyncMessage

// required int32 message_type = 1;
inline bool SyncMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncMessage::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 SyncMessage::message_type() const {
  return message_type_;
}
inline void SyncMessage::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
}

// optional bytes channel_id = 2;
inline bool SyncMessage::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncMessage::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncMessage::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncMessage::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& SyncMessage::channel_id() const {
  return *channel_id_;
}
inline void SyncMessage::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void SyncMessage::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void SyncMessage::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncMessage::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* SyncMessage::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncMessage::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes message_data = 3;
inline bool SyncMessage::has_message_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncMessage::set_has_message_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncMessage::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncMessage::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& SyncMessage::message_data() const {
  return *message_data_;
}
inline void SyncMessage::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void SyncMessage::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void SyncMessage::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncMessage::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  return message_data_;
}
inline ::std::string* SyncMessage::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncMessage::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 expire = 4;
inline bool SyncMessage::has_expire() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncMessage::set_has_expire() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncMessage::clear_has_expire() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncMessage::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 SyncMessage::expire() const {
  return expire_;
}
inline void SyncMessage::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional uint32 entire_expire = 5;
inline bool SyncMessage::has_entire_expire() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncMessage::set_has_entire_expire() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncMessage::clear_has_entire_expire() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncMessage::clear_entire_expire() {
  entire_expire_ = 0u;
  clear_has_entire_expire();
}
inline ::google::protobuf::uint32 SyncMessage::entire_expire() const {
  return entire_expire_;
}
inline void SyncMessage::set_entire_expire(::google::protobuf::uint32 value) {
  set_has_entire_expire();
  entire_expire_ = value;
}

// optional uint32 length = 6;
inline bool SyncMessage::has_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SyncMessage::set_has_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SyncMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SyncMessage::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 SyncMessage::length() const {
  return length_;
}
inline void SyncMessage::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// optional uint32 timestamp = 7;
inline bool SyncMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SyncMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SyncMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SyncMessage::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 SyncMessage::timestamp() const {
  return timestamp_;
}
inline void SyncMessage::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// UserMessage

// required int32 message_type = 1;
inline bool UserMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMessage::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 UserMessage::message_type() const {
  return message_type_;
}
inline void UserMessage::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
}

// optional bytes message_data = 2;
inline bool UserMessage::has_message_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMessage::set_has_message_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMessage::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMessage::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& UserMessage::message_data() const {
  return *message_data_;
}
inline void UserMessage::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void UserMessage::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void UserMessage::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMessage::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  return message_data_;
}
inline ::std::string* UserMessage::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void UserMessage::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 expire = 3;
inline bool UserMessage::has_expire() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMessage::set_has_expire() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMessage::clear_has_expire() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMessage::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 UserMessage::expire() const {
  return expire_;
}
inline void UserMessage::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional uint32 entire_expire = 4;
inline bool UserMessage::has_entire_expire() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMessage::set_has_entire_expire() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMessage::clear_has_entire_expire() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMessage::clear_entire_expire() {
  entire_expire_ = 0u;
  clear_has_entire_expire();
}
inline ::google::protobuf::uint32 UserMessage::entire_expire() const {
  return entire_expire_;
}
inline void UserMessage::set_entire_expire(::google::protobuf::uint32 value) {
  set_has_entire_expire();
  entire_expire_ = value;
}

// optional uint32 length = 5;
inline bool UserMessage::has_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMessage::set_has_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMessage::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 UserMessage::length() const {
  return length_;
}
inline void UserMessage::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// optional uint32 timestamp = 6;
inline bool UserMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMessage::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 UserMessage::timestamp() const {
  return timestamp_;
}
inline void UserMessage::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint32 device_type = 7;
inline bool UserMessage::has_device_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserMessage::set_has_device_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserMessage::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserMessage::clear_device_type() {
  device_type_ = 0u;
  clear_has_device_type();
}
inline ::google::protobuf::uint32 UserMessage::device_type() const {
  return device_type_;
}
inline void UserMessage::set_device_type(::google::protobuf::uint32 value) {
  set_has_device_type();
  device_type_ = value;
}

// -------------------------------------------------------------------

// UserMessageReply

// required uint64 message_id = 2;
inline bool UserMessageReply::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMessageReply::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMessageReply::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMessageReply::clear_message_id() {
  message_id_ = GOOGLE_ULONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::uint64 UserMessageReply::message_id() const {
  return message_id_;
}
inline void UserMessageReply::set_message_id(::google::protobuf::uint64 value) {
  set_has_message_id();
  message_id_ = value;
}

// optional bytes channel_id = 1;
inline bool UserMessageReply::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMessageReply::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMessageReply::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMessageReply::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& UserMessageReply::channel_id() const {
  return *channel_id_;
}
inline void UserMessageReply::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void UserMessageReply::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void UserMessageReply::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMessageReply::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}
inline ::std::string* UserMessageReply::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void UserMessageReply::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// IceKeepalive

// required .peersafe.imapi.protobuf.IceKeepalive.MessageType message_type = 1;
inline bool IceKeepalive::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceKeepalive::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceKeepalive::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceKeepalive::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::peersafe::imapi::protobuf::IceKeepalive_MessageType IceKeepalive::message_type() const {
  return static_cast< ::peersafe::imapi::protobuf::IceKeepalive_MessageType >(message_type_);
}
inline void IceKeepalive::set_message_type(::peersafe::imapi::protobuf::IceKeepalive_MessageType value) {
  assert(::peersafe::imapi::protobuf::IceKeepalive_MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// required bytes random = 2;
inline bool IceKeepalive::has_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IceKeepalive::set_has_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IceKeepalive::clear_has_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IceKeepalive::clear_random() {
  if (random_ != &::google::protobuf::internal::GetEmptyString()) {
    random_->clear();
  }
  clear_has_random();
}
inline const ::std::string& IceKeepalive::random() const {
  return *random_;
}
inline void IceKeepalive::set_random(const ::std::string& value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::GetEmptyString()) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void IceKeepalive::set_random(const char* value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::GetEmptyString()) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void IceKeepalive::set_random(const void* value, size_t size) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::GetEmptyString()) {
    random_ = new ::std::string;
  }
  random_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IceKeepalive::mutable_random() {
  set_has_random();
  if (random_ == &::google::protobuf::internal::GetEmptyString()) {
    random_ = new ::std::string;
  }
  return random_;
}
inline ::std::string* IceKeepalive::release_random() {
  clear_has_random();
  if (random_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = random_;
    random_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void IceKeepalive::set_allocated_random(::std::string* random) {
  if (random_ != &::google::protobuf::internal::GetEmptyString()) {
    delete random_;
  }
  if (random) {
    set_has_random();
    random_ = random;
  } else {
    clear_has_random();
    random_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// FriendRequest

// required bytes channel_public_key = 1;
inline bool FriendRequest::has_channel_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendRequest::set_has_channel_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendRequest::clear_has_channel_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendRequest::clear_channel_public_key() {
  if (channel_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    channel_public_key_->clear();
  }
  clear_has_channel_public_key();
}
inline const ::std::string& FriendRequest::channel_public_key() const {
  return *channel_public_key_;
}
inline void FriendRequest::set_channel_public_key(const ::std::string& value) {
  set_has_channel_public_key();
  if (channel_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_public_key_ = new ::std::string;
  }
  channel_public_key_->assign(value);
}
inline void FriendRequest::set_channel_public_key(const char* value) {
  set_has_channel_public_key();
  if (channel_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_public_key_ = new ::std::string;
  }
  channel_public_key_->assign(value);
}
inline void FriendRequest::set_channel_public_key(const void* value, size_t size) {
  set_has_channel_public_key();
  if (channel_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_public_key_ = new ::std::string;
  }
  channel_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendRequest::mutable_channel_public_key() {
  set_has_channel_public_key();
  if (channel_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_public_key_ = new ::std::string;
  }
  return channel_public_key_;
}
inline ::std::string* FriendRequest::release_channel_public_key() {
  clear_has_channel_public_key();
  if (channel_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = channel_public_key_;
    channel_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FriendRequest::set_allocated_channel_public_key(::std::string* channel_public_key) {
  if (channel_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete channel_public_key_;
  }
  if (channel_public_key) {
    set_has_channel_public_key();
    channel_public_key_ = channel_public_key;
  } else {
    clear_has_channel_public_key();
    channel_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes channel_private_key = 2;
inline bool FriendRequest::has_channel_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendRequest::set_has_channel_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendRequest::clear_has_channel_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendRequest::clear_channel_private_key() {
  if (channel_private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    channel_private_key_->clear();
  }
  clear_has_channel_private_key();
}
inline const ::std::string& FriendRequest::channel_private_key() const {
  return *channel_private_key_;
}
inline void FriendRequest::set_channel_private_key(const ::std::string& value) {
  set_has_channel_private_key();
  if (channel_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_private_key_ = new ::std::string;
  }
  channel_private_key_->assign(value);
}
inline void FriendRequest::set_channel_private_key(const char* value) {
  set_has_channel_private_key();
  if (channel_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_private_key_ = new ::std::string;
  }
  channel_private_key_->assign(value);
}
inline void FriendRequest::set_channel_private_key(const void* value, size_t size) {
  set_has_channel_private_key();
  if (channel_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_private_key_ = new ::std::string;
  }
  channel_private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendRequest::mutable_channel_private_key() {
  set_has_channel_private_key();
  if (channel_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_private_key_ = new ::std::string;
  }
  return channel_private_key_;
}
inline ::std::string* FriendRequest::release_channel_private_key() {
  clear_has_channel_private_key();
  if (channel_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = channel_private_key_;
    channel_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FriendRequest::set_allocated_channel_private_key(::std::string* channel_private_key) {
  if (channel_private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete channel_private_key_;
  }
  if (channel_private_key) {
    set_has_channel_private_key();
    channel_private_key_ = channel_private_key;
  } else {
    clear_has_channel_private_key();
    channel_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes session_public_key = 3;
inline bool FriendRequest::has_session_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendRequest::set_has_session_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendRequest::clear_has_session_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendRequest::clear_session_public_key() {
  if (session_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_->clear();
  }
  clear_has_session_public_key();
}
inline const ::std::string& FriendRequest::session_public_key() const {
  return *session_public_key_;
}
inline void FriendRequest::set_session_public_key(const ::std::string& value) {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  session_public_key_->assign(value);
}
inline void FriendRequest::set_session_public_key(const char* value) {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  session_public_key_->assign(value);
}
inline void FriendRequest::set_session_public_key(const void* value, size_t size) {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  session_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendRequest::mutable_session_public_key() {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  return session_public_key_;
}
inline ::std::string* FriendRequest::release_session_public_key() {
  clear_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = session_public_key_;
    session_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FriendRequest::set_allocated_session_public_key(::std::string* session_public_key) {
  if (session_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete session_public_key_;
  }
  if (session_public_key) {
    set_has_session_public_key();
    session_public_key_ = session_public_key;
  } else {
    clear_has_session_public_key();
    session_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes info = 4;
inline bool FriendRequest::has_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendRequest::set_has_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendRequest::clear_has_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendRequest::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& FriendRequest::info() const {
  return *info_;
}
inline void FriendRequest::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void FriendRequest::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void FriendRequest::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendRequest::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* FriendRequest::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FriendRequest::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes flags = 5;
inline bool FriendRequest::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendRequest::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendRequest::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendRequest::clear_flags() {
  if (flags_ != &::google::protobuf::internal::GetEmptyString()) {
    flags_->clear();
  }
  clear_has_flags();
}
inline const ::std::string& FriendRequest::flags() const {
  return *flags_;
}
inline void FriendRequest::set_flags(const ::std::string& value) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  flags_->assign(value);
}
inline void FriendRequest::set_flags(const char* value) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  flags_->assign(value);
}
inline void FriendRequest::set_flags(const void* value, size_t size) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  flags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendRequest::mutable_flags() {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    flags_ = new ::std::string;
  }
  return flags_;
}
inline ::std::string* FriendRequest::release_flags() {
  clear_has_flags();
  if (flags_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = flags_;
    flags_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FriendRequest::set_allocated_flags(::std::string* flags) {
  if (flags_ != &::google::protobuf::internal::GetEmptyString()) {
    delete flags_;
  }
  if (flags) {
    set_has_flags();
    flags_ = flags;
  } else {
    clear_has_flags();
    flags_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// FriendReply

// required bool accepted = 1;
inline bool FriendReply::has_accepted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendReply::set_has_accepted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendReply::clear_has_accepted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendReply::clear_accepted() {
  accepted_ = false;
  clear_has_accepted();
}
inline bool FriendReply::accepted() const {
  return accepted_;
}
inline void FriendReply::set_accepted(bool value) {
  set_has_accepted();
  accepted_ = value;
}

// optional bytes session_public_key = 2;
inline bool FriendReply::has_session_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendReply::set_has_session_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendReply::clear_has_session_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendReply::clear_session_public_key() {
  if (session_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_->clear();
  }
  clear_has_session_public_key();
}
inline const ::std::string& FriendReply::session_public_key() const {
  return *session_public_key_;
}
inline void FriendReply::set_session_public_key(const ::std::string& value) {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  session_public_key_->assign(value);
}
inline void FriendReply::set_session_public_key(const char* value) {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  session_public_key_->assign(value);
}
inline void FriendReply::set_session_public_key(const void* value, size_t size) {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  session_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendReply::mutable_session_public_key() {
  set_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    session_public_key_ = new ::std::string;
  }
  return session_public_key_;
}
inline ::std::string* FriendReply::release_session_public_key() {
  clear_has_session_public_key();
  if (session_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = session_public_key_;
    session_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FriendReply::set_allocated_session_public_key(::std::string* session_public_key) {
  if (session_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete session_public_key_;
  }
  if (session_public_key) {
    set_has_session_public_key();
    session_public_key_ = session_public_key;
  } else {
    clear_has_session_public_key();
    session_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// IceService

// required bytes host = 1;
inline bool IceService::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceService::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceService::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceService::clear_host() {
  if (host_ != &::google::protobuf::internal::GetEmptyString()) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& IceService::host() const {
  return *host_;
}
inline void IceService::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyString()) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void IceService::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyString()) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void IceService::set_host(const void* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyString()) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IceService::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyString()) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* IceService::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void IceService::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::GetEmptyString()) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes uid = 2;
inline bool IceService::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IceService::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IceService::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IceService::clear_uid() {
  if (uid_ != &::google::protobuf::internal::GetEmptyString()) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& IceService::uid() const {
  return *uid_;
}
inline void IceService::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyString()) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IceService::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyString()) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IceService::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyString()) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IceService::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyString()) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* IceService::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void IceService::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes pwd = 3;
inline bool IceService::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IceService::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IceService::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IceService::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::GetEmptyString()) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& IceService::pwd() const {
  return *pwd_;
}
inline void IceService::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyString()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void IceService::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyString()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void IceService::set_pwd(const void* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyString()) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IceService::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyString()) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* IceService::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void IceService::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::GetEmptyString()) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// IceServiceCache

// optional uint64 timestamp = 1;
inline bool IceServiceCache::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceServiceCache::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceServiceCache::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceServiceCache::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 IceServiceCache::timestamp() const {
  return timestamp_;
}
inline void IceServiceCache::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated .peersafe.imapi.protobuf.IceService items = 2;
inline int IceServiceCache::items_size() const {
  return items_.size();
}
inline void IceServiceCache::clear_items() {
  items_.Clear();
}
inline const ::peersafe::imapi::protobuf::IceService& IceServiceCache::items(int index) const {
  return items_.Get(index);
}
inline ::peersafe::imapi::protobuf::IceService* IceServiceCache::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::peersafe::imapi::protobuf::IceService* IceServiceCache::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::IceService >&
IceServiceCache::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::IceService >*
IceServiceCache::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// IceHandleShake

// required .peersafe.imapi.protobuf.IceHandleShake.MessageType message_type = 1;
inline bool IceHandleShake::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceHandleShake::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceHandleShake::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceHandleShake::clear_message_type() {
  message_type_ = 1;
  clear_has_message_type();
}
inline ::peersafe::imapi::protobuf::IceHandleShake_MessageType IceHandleShake::message_type() const {
  return static_cast< ::peersafe::imapi::protobuf::IceHandleShake_MessageType >(message_type_);
}
inline void IceHandleShake::set_message_type(::peersafe::imapi::protobuf::IceHandleShake_MessageType value) {
  assert(::peersafe::imapi::protobuf::IceHandleShake_MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// -------------------------------------------------------------------

// IceSdp

// required .peersafe.imapi.protobuf.IceSdp.MessageType message_type = 1;
inline bool IceSdp::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IceSdp::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IceSdp::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IceSdp::clear_message_type() {
  message_type_ = 1;
  clear_has_message_type();
}
inline ::peersafe::imapi::protobuf::IceSdp_MessageType IceSdp::message_type() const {
  return static_cast< ::peersafe::imapi::protobuf::IceSdp_MessageType >(message_type_);
}
inline void IceSdp::set_message_type(::peersafe::imapi::protobuf::IceSdp_MessageType value) {
  assert(::peersafe::imapi::protobuf::IceSdp_MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// required bytes sdp = 2;
inline bool IceSdp::has_sdp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IceSdp::set_has_sdp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IceSdp::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IceSdp::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::GetEmptyString()) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& IceSdp::sdp() const {
  return *sdp_;
}
inline void IceSdp::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::GetEmptyString()) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void IceSdp::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::GetEmptyString()) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void IceSdp::set_sdp(const void* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::GetEmptyString()) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IceSdp::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::GetEmptyString()) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* IceSdp::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void IceSdp::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::GetEmptyString()) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .peersafe.imapi.protobuf.IceService ice_srv = 3;
inline bool IceSdp::has_ice_srv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IceSdp::set_has_ice_srv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IceSdp::clear_has_ice_srv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IceSdp::clear_ice_srv() {
  if (ice_srv_ != NULL) ice_srv_->::peersafe::imapi::protobuf::IceService::Clear();
  clear_has_ice_srv();
}
inline const ::peersafe::imapi::protobuf::IceService& IceSdp::ice_srv() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ice_srv_ != NULL ? *ice_srv_ : *default_instance().ice_srv_;
#else
  return ice_srv_ != NULL ? *ice_srv_ : *default_instance_->ice_srv_;
#endif
}
inline ::peersafe::imapi::protobuf::IceService* IceSdp::mutable_ice_srv() {
  set_has_ice_srv();
  if (ice_srv_ == NULL) ice_srv_ = new ::peersafe::imapi::protobuf::IceService;
  return ice_srv_;
}
inline ::peersafe::imapi::protobuf::IceService* IceSdp::release_ice_srv() {
  clear_has_ice_srv();
  ::peersafe::imapi::protobuf::IceService* temp = ice_srv_;
  ice_srv_ = NULL;
  return temp;
}
inline void IceSdp::set_allocated_ice_srv(::peersafe::imapi::protobuf::IceService* ice_srv) {
  delete ice_srv_;
  ice_srv_ = ice_srv;
  if (ice_srv) {
    set_has_ice_srv();
  } else {
    clear_has_ice_srv();
  }
}

// optional int32 version = 4;
inline bool IceSdp::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IceSdp::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IceSdp::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IceSdp::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 IceSdp::version() const {
  return version_;
}
inline void IceSdp::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// ChannelMessage

// required bool encrypted = 1;
inline bool ChannelMessage::has_encrypted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelMessage::set_has_encrypted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelMessage::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelMessage::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool ChannelMessage::encrypted() const {
  return encrypted_;
}
inline void ChannelMessage::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
}

// required bytes data = 2;
inline bool ChannelMessage::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChannelMessage::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChannelMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChannelMessage::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ChannelMessage::data() const {
  return *data_;
}
inline void ChannelMessage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ChannelMessage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ChannelMessage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelMessage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ChannelMessage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ChannelMessage::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// DirectConnectionMessage

// required .peersafe.imapi.protobuf.DirectConnectionMessage.MessageType type = 1;
inline bool DirectConnectionMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectConnectionMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectConnectionMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectConnectionMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::peersafe::imapi::protobuf::DirectConnectionMessage_MessageType DirectConnectionMessage::type() const {
  return static_cast< ::peersafe::imapi::protobuf::DirectConnectionMessage_MessageType >(type_);
}
inline void DirectConnectionMessage::set_type(::peersafe::imapi::protobuf::DirectConnectionMessage_MessageType value) {
  assert(::peersafe::imapi::protobuf::DirectConnectionMessage_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes data = 2;
inline bool DirectConnectionMessage::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectConnectionMessage::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectConnectionMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectConnectionMessage::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& DirectConnectionMessage::data() const {
  return *data_;
}
inline void DirectConnectionMessage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void DirectConnectionMessage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void DirectConnectionMessage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectConnectionMessage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* DirectConnectionMessage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DirectConnectionMessage::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes friend_channel_id = 3;
inline bool DirectConnectionMessage::has_friend_channel_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectConnectionMessage::set_has_friend_channel_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectConnectionMessage::clear_has_friend_channel_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectConnectionMessage::clear_friend_channel_id() {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_->clear();
  }
  clear_has_friend_channel_id();
}
inline const ::std::string& DirectConnectionMessage::friend_channel_id() const {
  return *friend_channel_id_;
}
inline void DirectConnectionMessage::set_friend_channel_id(const ::std::string& value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void DirectConnectionMessage::set_friend_channel_id(const char* value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void DirectConnectionMessage::set_friend_channel_id(const void* value, size_t size) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectConnectionMessage::mutable_friend_channel_id() {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  return friend_channel_id_;
}
inline ::std::string* DirectConnectionMessage::release_friend_channel_id() {
  clear_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_channel_id_;
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DirectConnectionMessage::set_allocated_friend_channel_id(::std::string* friend_channel_id) {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_channel_id_;
  }
  if (friend_channel_id) {
    set_has_friend_channel_id();
    friend_channel_id_ = friend_channel_id;
  } else {
    clear_has_friend_channel_id();
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GroupChatInvite

// required bytes group_public_key = 1;
inline bool GroupChatInvite::has_group_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChatInvite::set_has_group_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChatInvite::clear_has_group_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChatInvite::clear_group_public_key() {
  if (group_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_->clear();
  }
  clear_has_group_public_key();
}
inline const ::std::string& GroupChatInvite::group_public_key() const {
  return *group_public_key_;
}
inline void GroupChatInvite::set_group_public_key(const ::std::string& value) {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  group_public_key_->assign(value);
}
inline void GroupChatInvite::set_group_public_key(const char* value) {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  group_public_key_->assign(value);
}
inline void GroupChatInvite::set_group_public_key(const void* value, size_t size) {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  group_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChatInvite::mutable_group_public_key() {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  return group_public_key_;
}
inline ::std::string* GroupChatInvite::release_group_public_key() {
  clear_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_public_key_;
    group_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupChatInvite::set_allocated_group_public_key(::std::string* group_public_key) {
  if (group_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_public_key_;
  }
  if (group_public_key) {
    set_has_group_public_key();
    group_public_key_ = group_public_key;
  } else {
    clear_has_group_public_key();
    group_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes group_private_key = 2;
inline bool GroupChatInvite::has_group_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChatInvite::set_has_group_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChatInvite::clear_has_group_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChatInvite::clear_group_private_key() {
  if (group_private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_->clear();
  }
  clear_has_group_private_key();
}
inline const ::std::string& GroupChatInvite::group_private_key() const {
  return *group_private_key_;
}
inline void GroupChatInvite::set_group_private_key(const ::std::string& value) {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  group_private_key_->assign(value);
}
inline void GroupChatInvite::set_group_private_key(const char* value) {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  group_private_key_->assign(value);
}
inline void GroupChatInvite::set_group_private_key(const void* value, size_t size) {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  group_private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChatInvite::mutable_group_private_key() {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  return group_private_key_;
}
inline ::std::string* GroupChatInvite::release_group_private_key() {
  clear_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_private_key_;
    group_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupChatInvite::set_allocated_group_private_key(::std::string* group_private_key) {
  if (group_private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_private_key_;
  }
  if (group_private_key) {
    set_has_group_private_key();
    group_private_key_ = group_private_key;
  } else {
    clear_has_group_private_key();
    group_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes info = 3;
inline bool GroupChatInvite::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupChatInvite::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupChatInvite::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupChatInvite::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& GroupChatInvite::info() const {
  return *info_;
}
inline void GroupChatInvite::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void GroupChatInvite::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void GroupChatInvite::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChatInvite::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* GroupChatInvite::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupChatInvite::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GroupChatInviteReply

// required bool accepted = 1;
inline bool GroupChatInviteReply::has_accepted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChatInviteReply::set_has_accepted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChatInviteReply::clear_has_accepted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChatInviteReply::clear_accepted() {
  accepted_ = false;
  clear_has_accepted();
}
inline bool GroupChatInviteReply::accepted() const {
  return accepted_;
}
inline void GroupChatInviteReply::set_accepted(bool value) {
  set_has_accepted();
  accepted_ = value;
}

// required bytes info = 2;
inline bool GroupChatInviteReply::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChatInviteReply::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChatInviteReply::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChatInviteReply::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& GroupChatInviteReply::info() const {
  return *info_;
}
inline void GroupChatInviteReply::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void GroupChatInviteReply::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void GroupChatInviteReply::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChatInviteReply::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* GroupChatInviteReply::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupChatInviteReply::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes group_channel_id = 3;
inline bool GroupChatInviteReply::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupChatInviteReply::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupChatInviteReply::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupChatInviteReply::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupChatInviteReply::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupChatInviteReply::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupChatInviteReply::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupChatInviteReply::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChatInviteReply::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupChatInviteReply::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupChatInviteReply::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GroupUserMessage

// required int32 message_type = 1;
inline bool GroupUserMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUserMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUserMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUserMessage::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 GroupUserMessage::message_type() const {
  return message_type_;
}
inline void GroupUserMessage::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
}

// optional bytes message_data = 2;
inline bool GroupUserMessage::has_message_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUserMessage::set_has_message_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUserMessage::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUserMessage::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& GroupUserMessage::message_data() const {
  return *message_data_;
}
inline void GroupUserMessage::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void GroupUserMessage::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void GroupUserMessage::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupUserMessage::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    message_data_ = new ::std::string;
  }
  return message_data_;
}
inline ::std::string* GroupUserMessage::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupUserMessage::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 expire = 3;
inline bool GroupUserMessage::has_expire() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUserMessage::set_has_expire() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUserMessage::clear_has_expire() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUserMessage::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 GroupUserMessage::expire() const {
  return expire_;
}
inline void GroupUserMessage::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional uint32 entire_expire = 4;
inline bool GroupUserMessage::has_entire_expire() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupUserMessage::set_has_entire_expire() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupUserMessage::clear_has_entire_expire() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupUserMessage::clear_entire_expire() {
  entire_expire_ = 0u;
  clear_has_entire_expire();
}
inline ::google::protobuf::uint32 GroupUserMessage::entire_expire() const {
  return entire_expire_;
}
inline void GroupUserMessage::set_entire_expire(::google::protobuf::uint32 value) {
  set_has_entire_expire();
  entire_expire_ = value;
}

// optional uint32 length = 5;
inline bool GroupUserMessage::has_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupUserMessage::set_has_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupUserMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupUserMessage::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 GroupUserMessage::length() const {
  return length_;
}
inline void GroupUserMessage::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// optional uint32 timestamp = 6;
inline bool GroupUserMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupUserMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupUserMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupUserMessage::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 GroupUserMessage::timestamp() const {
  return timestamp_;
}
inline void GroupUserMessage::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required bytes info = 7;
inline bool GroupUserMessage::has_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupUserMessage::set_has_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupUserMessage::clear_has_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupUserMessage::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& GroupUserMessage::info() const {
  return *info_;
}
inline void GroupUserMessage::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void GroupUserMessage::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void GroupUserMessage::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupUserMessage::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* GroupUserMessage::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupUserMessage::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyString()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 device_type = 8;
inline bool GroupUserMessage::has_device_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupUserMessage::set_has_device_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupUserMessage::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupUserMessage::clear_device_type() {
  device_type_ = 0u;
  clear_has_device_type();
}
inline ::google::protobuf::uint32 GroupUserMessage::device_type() const {
  return device_type_;
}
inline void GroupUserMessage::set_device_type(::google::protobuf::uint32 value) {
  set_has_device_type();
  device_type_ = value;
}

// -------------------------------------------------------------------

// GroupChannelData

// required bytes data = 1;
inline bool GroupChannelData::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChannelData::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChannelData::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChannelData::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& GroupChannelData::data() const {
  return *data_;
}
inline void GroupChannelData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GroupChannelData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GroupChannelData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChannelData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* GroupChannelData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupChannelData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 create = 2;
inline bool GroupChannelData::has_create() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChannelData::set_has_create() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChannelData::clear_has_create() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChannelData::clear_create() {
  create_ = GOOGLE_ULONGLONG(0);
  clear_has_create();
}
inline ::google::protobuf::uint64 GroupChannelData::create() const {
  return create_;
}
inline void GroupChannelData::set_create(::google::protobuf::uint64 value) {
  set_has_create();
  create_ = value;
}

// required uint64 expire = 3;
inline bool GroupChannelData::has_expire() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupChannelData::set_has_expire() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupChannelData::clear_has_expire() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupChannelData::clear_expire() {
  expire_ = GOOGLE_ULONGLONG(0);
  clear_has_expire();
}
inline ::google::protobuf::uint64 GroupChannelData::expire() const {
  return expire_;
}
inline void GroupChannelData::set_expire(::google::protobuf::uint64 value) {
  set_has_expire();
  expire_ = value;
}

// -------------------------------------------------------------------

// GroupChannelDatas

// repeated .peersafe.imapi.protobuf.GroupChannelData data = 1;
inline int GroupChannelDatas::data_size() const {
  return data_.size();
}
inline void GroupChannelDatas::clear_data() {
  data_.Clear();
}
inline const ::peersafe::imapi::protobuf::GroupChannelData& GroupChannelDatas::data(int index) const {
  return data_.Get(index);
}
inline ::peersafe::imapi::protobuf::GroupChannelData* GroupChannelDatas::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::peersafe::imapi::protobuf::GroupChannelData* GroupChannelDatas::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::GroupChannelData >&
GroupChannelDatas::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::peersafe::imapi::protobuf::GroupChannelData >*
GroupChannelDatas::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// GroupSyncChatInvite

// required bytes friend_channel_id = 1;
inline bool GroupSyncChatInvite::has_friend_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSyncChatInvite::set_has_friend_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSyncChatInvite::clear_has_friend_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSyncChatInvite::clear_friend_channel_id() {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_->clear();
  }
  clear_has_friend_channel_id();
}
inline const ::std::string& GroupSyncChatInvite::friend_channel_id() const {
  return *friend_channel_id_;
}
inline void GroupSyncChatInvite::set_friend_channel_id(const ::std::string& value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void GroupSyncChatInvite::set_friend_channel_id(const char* value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void GroupSyncChatInvite::set_friend_channel_id(const void* value, size_t size) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInvite::mutable_friend_channel_id() {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  return friend_channel_id_;
}
inline ::std::string* GroupSyncChatInvite::release_friend_channel_id() {
  clear_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_channel_id_;
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInvite::set_allocated_friend_channel_id(::std::string* friend_channel_id) {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_channel_id_;
  }
  if (friend_channel_id) {
    set_has_friend_channel_id();
    friend_channel_id_ = friend_channel_id;
  } else {
    clear_has_friend_channel_id();
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes group_channel_id = 2;
inline bool GroupSyncChatInvite::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSyncChatInvite::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSyncChatInvite::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSyncChatInvite::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupSyncChatInvite::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupSyncChatInvite::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncChatInvite::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncChatInvite::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInvite::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupSyncChatInvite::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInvite::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes my_name = 3;
inline bool GroupSyncChatInvite::has_my_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSyncChatInvite::set_has_my_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSyncChatInvite::clear_has_my_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSyncChatInvite::clear_my_name() {
  if (my_name_ != &::google::protobuf::internal::GetEmptyString()) {
    my_name_->clear();
  }
  clear_has_my_name();
}
inline const ::std::string& GroupSyncChatInvite::my_name() const {
  return *my_name_;
}
inline void GroupSyncChatInvite::set_my_name(const ::std::string& value) {
  set_has_my_name();
  if (my_name_ == &::google::protobuf::internal::GetEmptyString()) {
    my_name_ = new ::std::string;
  }
  my_name_->assign(value);
}
inline void GroupSyncChatInvite::set_my_name(const char* value) {
  set_has_my_name();
  if (my_name_ == &::google::protobuf::internal::GetEmptyString()) {
    my_name_ = new ::std::string;
  }
  my_name_->assign(value);
}
inline void GroupSyncChatInvite::set_my_name(const void* value, size_t size) {
  set_has_my_name();
  if (my_name_ == &::google::protobuf::internal::GetEmptyString()) {
    my_name_ = new ::std::string;
  }
  my_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInvite::mutable_my_name() {
  set_has_my_name();
  if (my_name_ == &::google::protobuf::internal::GetEmptyString()) {
    my_name_ = new ::std::string;
  }
  return my_name_;
}
inline ::std::string* GroupSyncChatInvite::release_my_name() {
  clear_has_my_name();
  if (my_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = my_name_;
    my_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInvite::set_allocated_my_name(::std::string* my_name) {
  if (my_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete my_name_;
  }
  if (my_name) {
    set_has_my_name();
    my_name_ = my_name;
  } else {
    clear_has_my_name();
    my_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes group_public_key = 4;
inline bool GroupSyncChatInvite::has_group_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSyncChatInvite::set_has_group_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSyncChatInvite::clear_has_group_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSyncChatInvite::clear_group_public_key() {
  if (group_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_->clear();
  }
  clear_has_group_public_key();
}
inline const ::std::string& GroupSyncChatInvite::group_public_key() const {
  return *group_public_key_;
}
inline void GroupSyncChatInvite::set_group_public_key(const ::std::string& value) {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  group_public_key_->assign(value);
}
inline void GroupSyncChatInvite::set_group_public_key(const char* value) {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  group_public_key_->assign(value);
}
inline void GroupSyncChatInvite::set_group_public_key(const void* value, size_t size) {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  group_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInvite::mutable_group_public_key() {
  set_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_public_key_ = new ::std::string;
  }
  return group_public_key_;
}
inline ::std::string* GroupSyncChatInvite::release_group_public_key() {
  clear_has_group_public_key();
  if (group_public_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_public_key_;
    group_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInvite::set_allocated_group_public_key(::std::string* group_public_key) {
  if (group_public_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_public_key_;
  }
  if (group_public_key) {
    set_has_group_public_key();
    group_public_key_ = group_public_key;
  } else {
    clear_has_group_public_key();
    group_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes group_private_key = 5;
inline bool GroupSyncChatInvite::has_group_private_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupSyncChatInvite::set_has_group_private_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupSyncChatInvite::clear_has_group_private_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupSyncChatInvite::clear_group_private_key() {
  if (group_private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_->clear();
  }
  clear_has_group_private_key();
}
inline const ::std::string& GroupSyncChatInvite::group_private_key() const {
  return *group_private_key_;
}
inline void GroupSyncChatInvite::set_group_private_key(const ::std::string& value) {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  group_private_key_->assign(value);
}
inline void GroupSyncChatInvite::set_group_private_key(const char* value) {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  group_private_key_->assign(value);
}
inline void GroupSyncChatInvite::set_group_private_key(const void* value, size_t size) {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  group_private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInvite::mutable_group_private_key() {
  set_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    group_private_key_ = new ::std::string;
  }
  return group_private_key_;
}
inline ::std::string* GroupSyncChatInvite::release_group_private_key() {
  clear_has_group_private_key();
  if (group_private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_private_key_;
    group_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInvite::set_allocated_group_private_key(::std::string* group_private_key) {
  if (group_private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_private_key_;
  }
  if (group_private_key) {
    set_has_group_private_key();
    group_private_key_ = group_private_key;
  } else {
    clear_has_group_private_key();
    group_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GroupSyncChatInviteReply

// required bytes friend_channel_id = 1;
inline bool GroupSyncChatInviteReply::has_friend_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSyncChatInviteReply::set_has_friend_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSyncChatInviteReply::clear_has_friend_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSyncChatInviteReply::clear_friend_channel_id() {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_->clear();
  }
  clear_has_friend_channel_id();
}
inline const ::std::string& GroupSyncChatInviteReply::friend_channel_id() const {
  return *friend_channel_id_;
}
inline void GroupSyncChatInviteReply::set_friend_channel_id(const ::std::string& value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void GroupSyncChatInviteReply::set_friend_channel_id(const char* value) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(value);
}
inline void GroupSyncChatInviteReply::set_friend_channel_id(const void* value, size_t size) {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  friend_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInviteReply::mutable_friend_channel_id() {
  set_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_channel_id_ = new ::std::string;
  }
  return friend_channel_id_;
}
inline ::std::string* GroupSyncChatInviteReply::release_friend_channel_id() {
  clear_has_friend_channel_id();
  if (friend_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_channel_id_;
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInviteReply::set_allocated_friend_channel_id(::std::string* friend_channel_id) {
  if (friend_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_channel_id_;
  }
  if (friend_channel_id) {
    set_has_friend_channel_id();
    friend_channel_id_ = friend_channel_id;
  } else {
    clear_has_friend_channel_id();
    friend_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes group_channel_id = 2;
inline bool GroupSyncChatInviteReply::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSyncChatInviteReply::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSyncChatInviteReply::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSyncChatInviteReply::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupSyncChatInviteReply::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupSyncChatInviteReply::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncChatInviteReply::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncChatInviteReply::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInviteReply::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupSyncChatInviteReply::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInviteReply::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bool accepted = 3;
inline bool GroupSyncChatInviteReply::has_accepted() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSyncChatInviteReply::set_has_accepted() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSyncChatInviteReply::clear_has_accepted() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSyncChatInviteReply::clear_accepted() {
  accepted_ = false;
  clear_has_accepted();
}
inline bool GroupSyncChatInviteReply::accepted() const {
  return accepted_;
}
inline void GroupSyncChatInviteReply::set_accepted(bool value) {
  set_has_accepted();
  accepted_ = value;
}

// required bytes friend_member_id = 4;
inline bool GroupSyncChatInviteReply::has_friend_member_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSyncChatInviteReply::set_has_friend_member_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSyncChatInviteReply::clear_has_friend_member_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSyncChatInviteReply::clear_friend_member_id() {
  if (friend_member_id_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_->clear();
  }
  clear_has_friend_member_id();
}
inline const ::std::string& GroupSyncChatInviteReply::friend_member_id() const {
  return *friend_member_id_;
}
inline void GroupSyncChatInviteReply::set_friend_member_id(const ::std::string& value) {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  friend_member_id_->assign(value);
}
inline void GroupSyncChatInviteReply::set_friend_member_id(const char* value) {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  friend_member_id_->assign(value);
}
inline void GroupSyncChatInviteReply::set_friend_member_id(const void* value, size_t size) {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  friend_member_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChatInviteReply::mutable_friend_member_id() {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  return friend_member_id_;
}
inline ::std::string* GroupSyncChatInviteReply::release_friend_member_id() {
  clear_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_member_id_;
    friend_member_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChatInviteReply::set_allocated_friend_member_id(::std::string* friend_member_id) {
  if (friend_member_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_member_id_;
  }
  if (friend_member_id) {
    set_has_friend_member_id();
    friend_member_id_ = friend_member_id;
  } else {
    clear_has_friend_member_id();
    friend_member_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GroupSyncNewMember

// required bytes group_channel_id = 1;
inline bool GroupSyncNewMember::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSyncNewMember::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSyncNewMember::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSyncNewMember::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupSyncNewMember::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupSyncNewMember::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncNewMember::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncNewMember::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncNewMember::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupSyncNewMember::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncNewMember::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes friend_member_id = 2;
inline bool GroupSyncNewMember::has_friend_member_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSyncNewMember::set_has_friend_member_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSyncNewMember::clear_has_friend_member_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSyncNewMember::clear_friend_member_id() {
  if (friend_member_id_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_->clear();
  }
  clear_has_friend_member_id();
}
inline const ::std::string& GroupSyncNewMember::friend_member_id() const {
  return *friend_member_id_;
}
inline void GroupSyncNewMember::set_friend_member_id(const ::std::string& value) {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  friend_member_id_->assign(value);
}
inline void GroupSyncNewMember::set_friend_member_id(const char* value) {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  friend_member_id_->assign(value);
}
inline void GroupSyncNewMember::set_friend_member_id(const void* value, size_t size) {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  friend_member_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncNewMember::mutable_friend_member_id() {
  set_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_member_id_ = new ::std::string;
  }
  return friend_member_id_;
}
inline ::std::string* GroupSyncNewMember::release_friend_member_id() {
  clear_has_friend_member_id();
  if (friend_member_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_member_id_;
    friend_member_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncNewMember::set_allocated_friend_member_id(::std::string* friend_member_id) {
  if (friend_member_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_member_id_;
  }
  if (friend_member_id) {
    set_has_friend_member_id();
    friend_member_id_ = friend_member_id;
  } else {
    clear_has_friend_member_id();
    friend_member_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes friend_name = 3;
inline bool GroupSyncNewMember::has_friend_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSyncNewMember::set_has_friend_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSyncNewMember::clear_has_friend_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSyncNewMember::clear_friend_name() {
  if (friend_name_ != &::google::protobuf::internal::GetEmptyString()) {
    friend_name_->clear();
  }
  clear_has_friend_name();
}
inline const ::std::string& GroupSyncNewMember::friend_name() const {
  return *friend_name_;
}
inline void GroupSyncNewMember::set_friend_name(const ::std::string& value) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(value);
}
inline void GroupSyncNewMember::set_friend_name(const char* value) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(value);
}
inline void GroupSyncNewMember::set_friend_name(const void* value, size_t size) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncNewMember::mutable_friend_name() {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::GetEmptyString()) {
    friend_name_ = new ::std::string;
  }
  return friend_name_;
}
inline ::std::string* GroupSyncNewMember::release_friend_name() {
  clear_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = friend_name_;
    friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncNewMember::set_allocated_friend_name(::std::string* friend_name) {
  if (friend_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete friend_name_;
  }
  if (friend_name) {
    set_has_friend_name();
    friend_name_ = friend_name;
  } else {
    clear_has_friend_name();
    friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 join_time = 4;
inline bool GroupSyncNewMember::has_join_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSyncNewMember::set_has_join_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSyncNewMember::clear_has_join_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSyncNewMember::clear_join_time() {
  join_time_ = GOOGLE_ULONGLONG(0);
  clear_has_join_time();
}
inline ::google::protobuf::uint64 GroupSyncNewMember::join_time() const {
  return join_time_;
}
inline void GroupSyncNewMember::set_join_time(::google::protobuf::uint64 value) {
  set_has_join_time();
  join_time_ = value;
}

// -------------------------------------------------------------------

// GroupSyncRemoveMember

// required bytes group_channel_id = 1;
inline bool GroupSyncRemoveMember::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSyncRemoveMember::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSyncRemoveMember::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSyncRemoveMember::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupSyncRemoveMember::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupSyncRemoveMember::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncRemoveMember::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncRemoveMember::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncRemoveMember::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupSyncRemoveMember::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncRemoveMember::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes remover_id = 2;
inline bool GroupSyncRemoveMember::has_remover_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSyncRemoveMember::set_has_remover_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSyncRemoveMember::clear_has_remover_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSyncRemoveMember::clear_remover_id() {
  if (remover_id_ != &::google::protobuf::internal::GetEmptyString()) {
    remover_id_->clear();
  }
  clear_has_remover_id();
}
inline const ::std::string& GroupSyncRemoveMember::remover_id() const {
  return *remover_id_;
}
inline void GroupSyncRemoveMember::set_remover_id(const ::std::string& value) {
  set_has_remover_id();
  if (remover_id_ == &::google::protobuf::internal::GetEmptyString()) {
    remover_id_ = new ::std::string;
  }
  remover_id_->assign(value);
}
inline void GroupSyncRemoveMember::set_remover_id(const char* value) {
  set_has_remover_id();
  if (remover_id_ == &::google::protobuf::internal::GetEmptyString()) {
    remover_id_ = new ::std::string;
  }
  remover_id_->assign(value);
}
inline void GroupSyncRemoveMember::set_remover_id(const void* value, size_t size) {
  set_has_remover_id();
  if (remover_id_ == &::google::protobuf::internal::GetEmptyString()) {
    remover_id_ = new ::std::string;
  }
  remover_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncRemoveMember::mutable_remover_id() {
  set_has_remover_id();
  if (remover_id_ == &::google::protobuf::internal::GetEmptyString()) {
    remover_id_ = new ::std::string;
  }
  return remover_id_;
}
inline ::std::string* GroupSyncRemoveMember::release_remover_id() {
  clear_has_remover_id();
  if (remover_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = remover_id_;
    remover_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncRemoveMember::set_allocated_remover_id(::std::string* remover_id) {
  if (remover_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete remover_id_;
  }
  if (remover_id) {
    set_has_remover_id();
    remover_id_ = remover_id;
  } else {
    clear_has_remover_id();
    remover_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes memeber_id = 3;
inline bool GroupSyncRemoveMember::has_memeber_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSyncRemoveMember::set_has_memeber_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSyncRemoveMember::clear_has_memeber_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSyncRemoveMember::clear_memeber_id() {
  if (memeber_id_ != &::google::protobuf::internal::GetEmptyString()) {
    memeber_id_->clear();
  }
  clear_has_memeber_id();
}
inline const ::std::string& GroupSyncRemoveMember::memeber_id() const {
  return *memeber_id_;
}
inline void GroupSyncRemoveMember::set_memeber_id(const ::std::string& value) {
  set_has_memeber_id();
  if (memeber_id_ == &::google::protobuf::internal::GetEmptyString()) {
    memeber_id_ = new ::std::string;
  }
  memeber_id_->assign(value);
}
inline void GroupSyncRemoveMember::set_memeber_id(const char* value) {
  set_has_memeber_id();
  if (memeber_id_ == &::google::protobuf::internal::GetEmptyString()) {
    memeber_id_ = new ::std::string;
  }
  memeber_id_->assign(value);
}
inline void GroupSyncRemoveMember::set_memeber_id(const void* value, size_t size) {
  set_has_memeber_id();
  if (memeber_id_ == &::google::protobuf::internal::GetEmptyString()) {
    memeber_id_ = new ::std::string;
  }
  memeber_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncRemoveMember::mutable_memeber_id() {
  set_has_memeber_id();
  if (memeber_id_ == &::google::protobuf::internal::GetEmptyString()) {
    memeber_id_ = new ::std::string;
  }
  return memeber_id_;
}
inline ::std::string* GroupSyncRemoveMember::release_memeber_id() {
  clear_has_memeber_id();
  if (memeber_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = memeber_id_;
    memeber_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncRemoveMember::set_allocated_memeber_id(::std::string* memeber_id) {
  if (memeber_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete memeber_id_;
  }
  if (memeber_id) {
    set_has_memeber_id();
    memeber_id_ = memeber_id;
  } else {
    clear_has_memeber_id();
    memeber_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 remove_time = 4;
inline bool GroupSyncRemoveMember::has_remove_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSyncRemoveMember::set_has_remove_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSyncRemoveMember::clear_has_remove_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSyncRemoveMember::clear_remove_time() {
  remove_time_ = GOOGLE_ULONGLONG(0);
  clear_has_remove_time();
}
inline ::google::protobuf::uint64 GroupSyncRemoveMember::remove_time() const {
  return remove_time_;
}
inline void GroupSyncRemoveMember::set_remove_time(::google::protobuf::uint64 value) {
  set_has_remove_time();
  remove_time_ = value;
}

// -------------------------------------------------------------------

// GroupSyncUserMessage

// required bytes group_channel_id = 1;
inline bool GroupSyncUserMessage::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSyncUserMessage::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSyncUserMessage::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSyncUserMessage::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupSyncUserMessage::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupSyncUserMessage::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncUserMessage::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncUserMessage::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncUserMessage::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupSyncUserMessage::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncUserMessage::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes author = 2;
inline bool GroupSyncUserMessage::has_author() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSyncUserMessage::set_has_author() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSyncUserMessage::clear_has_author() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSyncUserMessage::clear_author() {
  if (author_ != &::google::protobuf::internal::GetEmptyString()) {
    author_->clear();
  }
  clear_has_author();
}
inline const ::std::string& GroupSyncUserMessage::author() const {
  return *author_;
}
inline void GroupSyncUserMessage::set_author(const ::std::string& value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyString()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
}
inline void GroupSyncUserMessage::set_author(const char* value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyString()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
}
inline void GroupSyncUserMessage::set_author(const void* value, size_t size) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyString()) {
    author_ = new ::std::string;
  }
  author_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncUserMessage::mutable_author() {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyString()) {
    author_ = new ::std::string;
  }
  return author_;
}
inline ::std::string* GroupSyncUserMessage::release_author() {
  clear_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = author_;
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncUserMessage::set_allocated_author(::std::string* author) {
  if (author_ != &::google::protobuf::internal::GetEmptyString()) {
    delete author_;
  }
  if (author) {
    set_has_author();
    author_ = author;
  } else {
    clear_has_author();
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 type = 3;
inline bool GroupSyncUserMessage::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSyncUserMessage::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSyncUserMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSyncUserMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupSyncUserMessage::type() const {
  return type_;
}
inline void GroupSyncUserMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required bytes message = 4;
inline bool GroupSyncUserMessage::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSyncUserMessage::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSyncUserMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSyncUserMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyString()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& GroupSyncUserMessage::message() const {
  return *message_;
}
inline void GroupSyncUserMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void GroupSyncUserMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void GroupSyncUserMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncUserMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* GroupSyncUserMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncUserMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 message_id = 5;
inline bool GroupSyncUserMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupSyncUserMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupSyncUserMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupSyncUserMessage::clear_message_id() {
  message_id_ = GOOGLE_ULONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::uint64 GroupSyncUserMessage::message_id() const {
  return message_id_;
}
inline void GroupSyncUserMessage::set_message_id(::google::protobuf::uint64 value) {
  set_has_message_id();
  message_id_ = value;
}

// required uint32 expire = 6;
inline bool GroupSyncUserMessage::has_expire() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupSyncUserMessage::set_has_expire() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupSyncUserMessage::clear_has_expire() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupSyncUserMessage::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 GroupSyncUserMessage::expire() const {
  return expire_;
}
inline void GroupSyncUserMessage::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// required uint32 entire_expire = 7;
inline bool GroupSyncUserMessage::has_entire_expire() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupSyncUserMessage::set_has_entire_expire() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupSyncUserMessage::clear_has_entire_expire() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupSyncUserMessage::clear_entire_expire() {
  entire_expire_ = 0u;
  clear_has_entire_expire();
}
inline ::google::protobuf::uint32 GroupSyncUserMessage::entire_expire() const {
  return entire_expire_;
}
inline void GroupSyncUserMessage::set_entire_expire(::google::protobuf::uint32 value) {
  set_has_entire_expire();
  entire_expire_ = value;
}

// required uint32 length = 8;
inline bool GroupSyncUserMessage::has_length() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupSyncUserMessage::set_has_length() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupSyncUserMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupSyncUserMessage::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 GroupSyncUserMessage::length() const {
  return length_;
}
inline void GroupSyncUserMessage::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// required uint32 timestamp = 9;
inline bool GroupSyncUserMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupSyncUserMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupSyncUserMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupSyncUserMessage::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 GroupSyncUserMessage::timestamp() const {
  return timestamp_;
}
inline void GroupSyncUserMessage::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required bytes author_name = 10;
inline bool GroupSyncUserMessage::has_author_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupSyncUserMessage::set_has_author_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupSyncUserMessage::clear_has_author_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupSyncUserMessage::clear_author_name() {
  if (author_name_ != &::google::protobuf::internal::GetEmptyString()) {
    author_name_->clear();
  }
  clear_has_author_name();
}
inline const ::std::string& GroupSyncUserMessage::author_name() const {
  return *author_name_;
}
inline void GroupSyncUserMessage::set_author_name(const ::std::string& value) {
  set_has_author_name();
  if (author_name_ == &::google::protobuf::internal::GetEmptyString()) {
    author_name_ = new ::std::string;
  }
  author_name_->assign(value);
}
inline void GroupSyncUserMessage::set_author_name(const char* value) {
  set_has_author_name();
  if (author_name_ == &::google::protobuf::internal::GetEmptyString()) {
    author_name_ = new ::std::string;
  }
  author_name_->assign(value);
}
inline void GroupSyncUserMessage::set_author_name(const void* value, size_t size) {
  set_has_author_name();
  if (author_name_ == &::google::protobuf::internal::GetEmptyString()) {
    author_name_ = new ::std::string;
  }
  author_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncUserMessage::mutable_author_name() {
  set_has_author_name();
  if (author_name_ == &::google::protobuf::internal::GetEmptyString()) {
    author_name_ = new ::std::string;
  }
  return author_name_;
}
inline ::std::string* GroupSyncUserMessage::release_author_name() {
  clear_has_author_name();
  if (author_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = author_name_;
    author_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncUserMessage::set_allocated_author_name(::std::string* author_name) {
  if (author_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete author_name_;
  }
  if (author_name) {
    set_has_author_name();
    author_name_ = author_name;
  } else {
    clear_has_author_name();
    author_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GroupSyncChangeName

// required bytes group_channel_id = 1;
inline bool GroupSyncChangeName::has_group_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSyncChangeName::set_has_group_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSyncChangeName::clear_has_group_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSyncChangeName::clear_group_channel_id() {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_->clear();
  }
  clear_has_group_channel_id();
}
inline const ::std::string& GroupSyncChangeName::group_channel_id() const {
  return *group_channel_id_;
}
inline void GroupSyncChangeName::set_group_channel_id(const ::std::string& value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncChangeName::set_group_channel_id(const char* value) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(value);
}
inline void GroupSyncChangeName::set_group_channel_id(const void* value, size_t size) {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  group_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChangeName::mutable_group_channel_id() {
  set_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    group_channel_id_ = new ::std::string;
  }
  return group_channel_id_;
}
inline ::std::string* GroupSyncChangeName::release_group_channel_id() {
  clear_has_group_channel_id();
  if (group_channel_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_channel_id_;
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChangeName::set_allocated_group_channel_id(::std::string* group_channel_id) {
  if (group_channel_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_channel_id_;
  }
  if (group_channel_id) {
    set_has_group_channel_id();
    group_channel_id_ = group_channel_id;
  } else {
    clear_has_group_channel_id();
    group_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes channel_name = 2;
inline bool GroupSyncChangeName::has_channel_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSyncChangeName::set_has_channel_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSyncChangeName::clear_has_channel_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSyncChangeName::clear_channel_name() {
  if (channel_name_ != &::google::protobuf::internal::GetEmptyString()) {
    channel_name_->clear();
  }
  clear_has_channel_name();
}
inline const ::std::string& GroupSyncChangeName::channel_name() const {
  return *channel_name_;
}
inline void GroupSyncChangeName::set_channel_name(const ::std::string& value) {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_name_ = new ::std::string;
  }
  channel_name_->assign(value);
}
inline void GroupSyncChangeName::set_channel_name(const char* value) {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_name_ = new ::std::string;
  }
  channel_name_->assign(value);
}
inline void GroupSyncChangeName::set_channel_name(const void* value, size_t size) {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_name_ = new ::std::string;
  }
  channel_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSyncChangeName::mutable_channel_name() {
  set_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::GetEmptyString()) {
    channel_name_ = new ::std::string;
  }
  return channel_name_;
}
inline ::std::string* GroupSyncChangeName::release_channel_name() {
  clear_has_channel_name();
  if (channel_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = channel_name_;
    channel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GroupSyncChangeName::set_allocated_channel_name(::std::string* channel_name) {
  if (channel_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete channel_name_;
  }
  if (channel_name) {
    set_has_channel_name();
    channel_name_ = channel_name;
  } else {
    clear_has_channel_name();
    channel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 changed_time = 3;
inline bool GroupSyncChangeName::has_changed_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSyncChangeName::set_has_changed_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSyncChangeName::clear_has_changed_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSyncChangeName::clear_changed_time() {
  changed_time_ = GOOGLE_ULONGLONG(0);
  clear_has_changed_time();
}
inline ::google::protobuf::uint64 GroupSyncChangeName::changed_time() const {
  return changed_time_;
}
inline void GroupSyncChangeName::set_changed_time(::google::protobuf::uint64 value) {
  set_has_changed_time();
  changed_time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace imapi
}  // namespace peersafe

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_peersafe_2fimapi_2fim_2eproto__INCLUDED
